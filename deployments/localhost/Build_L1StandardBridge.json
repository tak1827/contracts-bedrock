{
  "address": "0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "deployBytecode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xfd84ae5a5382a6ae99a9ebeaccaaf419df92cdd38e89135617dcdadbda9be11c",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e",
    "transactionIndex": 0,
    "gasUsed": "2279349",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x617457047c857dc1e60208a177be668fc58bcfa0a4cf56f9dde345d49a5e9a89",
    "transactionHash": "0xfd84ae5a5382a6ae99a9ebeaccaaf419df92cdd38e89135617dcdadbda9be11c",
    "logs": [],
    "blockNumber": 23,
    "cumulativeGasUsed": "2279349",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a59b28bf75faade9a91b10b17d788d3d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"deployBytecode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"version()\":{\"returns\":{\"_0\":\"Semver contract version as a string.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deployBytecode()\":{\"notice\":\"The create2 salt used for deployment of the contract implementations.\"},\"version()\":{\"notice\":\"Returns the full semver contract version.\"}},\"notice\":\"Hold the deployment bytecode         Separate from build contract to avoid bytecode size limitations\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oasys/L1Build/Build_L1StandardBridge.sol\":\"Build_L1StandardBridge\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x247c62047745915c0af6b955470a72d1696ebad4352d7d3011aef1a2463cd888\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0203dcadc5737d9ef2c211d6fa15d18ebc3b30dfa51903b64870b01a062b0b4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a21b14ff90012878752f230d3ffd5c3405e5938d06c97a7d89c0a64561d0d66\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x24b04b8aacaaf1a4a0719117b29c9c3647b1f479c5ac2a60f5ff1bb6d839c238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x032807210d1d7d218963d7355d62e021a84bf1b3339f4f50be2f63b53cccaf29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xaf159a8b1923ad2a26d516089bceca9bdeaeacd04be50983ea00ba63070f08a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0xc65c83c1039508fa7a42a09a3c6a32babd1c438ba4dbb23581255e784b5d5eed\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb3ebde1c8d27576db912d87c3560dab14adfb9cd001be95890ec4ba035e652e7\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x622fcd8a49e132df5ec7651cc6ae3aaf0cf59bdcd67a9a804a1b9e2485113b7d\",\"license\":\"MIT\"},\"contracts/L1/L1CrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\nimport { OptimismPortal } from \\\"./OptimismPortal.sol\\\";\\nimport { CrossDomainMessenger } from \\\"../universal/CrossDomainMessenger.sol\\\";\\nimport { ISemver } from \\\"../universal/ISemver.sol\\\";\\n\\n/// @custom:proxied\\n/// @title L1CrossDomainMessenger\\n/// @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\\n///         for sending and receiving data on the L1 side. Users are encouraged to use this\\n///         interface instead of interacting with lower-level contracts directly.\\ncontract L1CrossDomainMessenger is CrossDomainMessenger, ISemver {\\n    /// @notice Address of the OptimismPortal. The public getter for this\\n    ///         is legacy and will be removed in the future. Use `portal()` instead.\\n    /// @custom:network-specific\\n    /// @custom:legacy\\n    OptimismPortal public PORTAL;\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 1.6.0\\n    string public constant version = \\\"1.6.0\\\";\\n\\n    /// @notice Constructs the L1CrossDomainMessenger contract.\\n    constructor() CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER) {\\n        initialize({ _portal: OptimismPortal(payable(0)) });\\n    }\\n\\n    /// @notice Initializes the contract.\\n    /// @param _portal Address of the OptimismPortal contract on this network.\\n    function initialize(OptimismPortal _portal) public reinitializer(2) {\\n        PORTAL = _portal;\\n        __CrossDomainMessenger_init();\\n    }\\n\\n    /// @notice Getter for the OptimismPortal address.\\n    function portal() external view returns (address) {\\n        return address(PORTAL);\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal override {\\n        PORTAL.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _isOtherMessenger() internal view override returns (bool) {\\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\\n        return _target == address(this) || _target == address(PORTAL);\\n    }\\n}\\n\",\"keccak256\":\"0x428a417b56b87705f9dae986c751a69db04c30fbfd16e5e7fa97421b6a869edc\",\"license\":\"MIT\"},\"contracts/L1/L1StandardBridge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Predeploys } from \\\"../libraries/Predeploys.sol\\\";\\nimport { StandardBridge } from \\\"../universal/StandardBridge.sol\\\";\\nimport { ISemver } from \\\"../universal/ISemver.sol\\\";\\nimport { CrossDomainMessenger } from \\\"../universal/CrossDomainMessenger.sol\\\";\\n\\n/// @custom:proxied\\n/// @title L1StandardBridge\\n/// @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\\n///         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\\n///         contract. If the ERC20 token is native to L2, it will be burnt. Before Bedrock, ETH was\\n///         stored within this contract. After Bedrock, ETH is instead stored inside the\\n///         OptimismPortal contract.\\n///         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\\n///         of some token types that may not be properly supported by this contract include, but are\\n///         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\\ncontract L1StandardBridge is StandardBridge, ISemver {\\n    /// @custom:legacy\\n    /// @notice Emitted whenever a deposit of ETH from L1 into L2 is initiated.\\n    /// @param from      Address of the depositor.\\n    /// @param to        Address of the recipient on L2.\\n    /// @param amount    Amount of ETH deposited.\\n    /// @param extraData Extra data attached to the deposit.\\n    event ETHDepositInitiated(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @custom:legacy\\n    /// @notice Emitted whenever a withdrawal of ETH from L2 to L1 is finalized.\\n    /// @param from      Address of the withdrawer.\\n    /// @param to        Address of the recipient on L1.\\n    /// @param amount    Amount of ETH withdrawn.\\n    /// @param extraData Extra data attached to the withdrawal.\\n    event ETHWithdrawalFinalized(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @custom:legacy\\n    /// @notice Emitted whenever an ERC20 deposit is initiated.\\n    /// @param l1Token   Address of the token on L1.\\n    /// @param l2Token   Address of the corresponding token on L2.\\n    /// @param from      Address of the depositor.\\n    /// @param to        Address of the recipient on L2.\\n    /// @param amount    Amount of the ERC20 deposited.\\n    /// @param extraData Extra data attached to the deposit.\\n    event ERC20DepositInitiated(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @custom:legacy\\n    /// @notice Emitted whenever an ERC20 withdrawal is finalized.\\n    /// @param l1Token   Address of the token on L1.\\n    /// @param l2Token   Address of the corresponding token on L2.\\n    /// @param from      Address of the withdrawer.\\n    /// @param to        Address of the recipient on L1.\\n    /// @param amount    Amount of the ERC20 withdrawn.\\n    /// @param extraData Extra data attached to the withdrawal.\\n    event ERC20WithdrawalFinalized(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 1.3.0\\n    string public constant version = \\\"1.3.0\\\";\\n\\n    /// @notice Constructs the L1StandardBridge contract.\\n    constructor() StandardBridge(StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE))) {\\n        initialize({ _messenger: CrossDomainMessenger(address(0)) });\\n    }\\n\\n    /// @notice Storage slot 0 holds a legacy value on upgraded networks. It is an empty\\n    //          placeholder slot on new networks. Manually set it to 0 so that `Initializable`\\n    //          can use the first storage slot. This few lines of code helps to prevent a large\\n    //          diff in the source code to preserve the storage layout. This should be removed\\n    //          during the next contract upgrade.\\n    modifier clearLegacySlot() {\\n        assembly {\\n            sstore(0, 0)\\n        }\\n        _;\\n    }\\n\\n    /// @notice Initializer\\n    ///         The fix modifier should be removed during the next contract upgrade.\\n    function initialize(CrossDomainMessenger _messenger) public clearLegacySlot reinitializer(2) {\\n        __StandardBridge_init({ _messenger: _messenger });\\n    }\\n\\n    /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n    receive() external payable override onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\\\"\\\"));\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ETH into the sender's account on L2.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ETH into a target account on L2.\\n    ///         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\\n    ///         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\\n    ///         successfully replayed by increasing the amount of gas supplied to the call. If the\\n    ///         call will fail for any amount of gas, then the ETH will be locked permanently.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositETHTo(address _to, uint32 _minGasLimit, bytes calldata _extraData) external payable {\\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\\n    /// @param _l1Token     Address of the L1 token being deposited.\\n    /// @param _l2Token     Address of the corresponding token on L2.\\n    /// @param _amount      Amount of the ERC20 to deposit.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        external\\n        virtual\\n        onlyEOA\\n    {\\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ERC20 tokens into a target account on L2.\\n    /// @param _l1Token     Address of the L1 token being deposited.\\n    /// @param _l2Token     Address of the corresponding token on L2.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _amount      Amount of the ERC20 to deposit.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        external\\n        virtual\\n    {\\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Finalizes a withdrawal of ETH from L2.\\n    /// @param _from      Address of the withdrawer on L2.\\n    /// @param _to        Address of the recipient on L1.\\n    /// @param _amount    Amount of ETH to withdraw.\\n    /// @param _extraData Optional data forwarded from L2.\\n    function finalizeETHWithdrawal(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        external\\n        payable\\n    {\\n        finalizeBridgeETH(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Finalizes a withdrawal of ERC20 tokens from L2.\\n    /// @param _l1Token   Address of the token on L1.\\n    /// @param _l2Token   Address of the corresponding token on L2.\\n    /// @param _from      Address of the withdrawer on L2.\\n    /// @param _to        Address of the recipient on L1.\\n    /// @param _amount    Amount of the ERC20 to withdraw.\\n    /// @param _extraData Optional data forwarded from L2.\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        external\\n    {\\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Retrieves the access of the corresponding L2 bridge contract.\\n    /// @return Address of the corresponding L2 bridge contract.\\n    function l2TokenBridge() external view returns (address) {\\n        return address(OTHER_BRIDGE);\\n    }\\n\\n    /// @notice Internal function for initiating an ETH deposit.\\n    /// @param _from        Address of the sender on L1.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    function _initiateETHDeposit(address _from, address _to, uint32 _minGasLimit, bytes memory _extraData) internal {\\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Internal function for initiating an ERC20 deposit.\\n    /// @param _l1Token     Address of the L1 token being deposited.\\n    /// @param _l2Token     Address of the corresponding token on L2.\\n    /// @param _from        Address of the sender on L1.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _amount      Amount of the ERC20 to deposit.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    function _initiateERC20Deposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ETHDepositInitiated event followed by the ETHBridgeInitiated event.\\n    ///         This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ETHDepositInitiated(_from, _to, _amount, _extraData);\\n        super._emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ERC20DepositInitiated event followed by the ERC20BridgeInitiated\\n    ///         event. This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _extraData);\\n        super._emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ERC20WithdrawalFinalized event followed by the ERC20BridgeFinalized\\n    ///         event. This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ERC20DepositInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ERC20WithdrawalFinalized event followed by the ERC20BridgeFinalized\\n    ///         event. This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ERC20WithdrawalFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n}\\n\",\"keccak256\":\"0x7bb66c763b55703c4ae8ac5dbcfcf555b7004d00fa7fdac69b2518eaf5319370\",\"license\":\"MIT\"},\"contracts/L1/L2OutputOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { ISemver } from \\\"../universal/ISemver.sol\\\";\\nimport { Types } from \\\"../libraries/Types.sol\\\";\\n\\n/// @custom:proxied\\n/// @title L2OutputOracle\\n/// @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\\n///         commitment to the state of the L2 chain. Other contracts like the OptimismPortal use\\n///         these outputs to verify information about the state of L2.\\ncontract L2OutputOracle is Initializable, ISemver {\\n    /// @notice The interval in L2 blocks at which checkpoints must be submitted.\\n    ///         Although this is immutable, it can safely be modified by upgrading the\\n    ///         implementation contract.\\n    ///         Public getter is legacy and will be removed in the future. Use `submissionInterval`\\n    ///         instead.\\n    /// @custom:legacy\\n    uint256 public immutable SUBMISSION_INTERVAL;\\n\\n    /// @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\\n    ///         Public getter is legacy and will be removed in the future. Use `l2BlockTime`\\n    ///         instead.\\n    /// @custom:legacy\\n    uint256 public immutable L2_BLOCK_TIME;\\n\\n    /// @notice The minimum time (in seconds) that must elapse before a withdrawal can be finalized.\\n    ///         Public getter is legacy and will be removed in the future. Use\\n    //          `finalizationPeriodSeconds` instead.\\n    /// @custom:legacy\\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\\n\\n    /// @notice The number of the first L2 block recorded in this contract.\\n    uint256 public startingBlockNumber;\\n\\n    /// @notice The timestamp of the first L2 block recorded in this contract.\\n    uint256 public startingTimestamp;\\n\\n    /// @notice An array of L2 output proposals.\\n    Types.OutputProposal[] internal l2Outputs;\\n\\n    /// @notice The address of the challenger. Can be updated via reinitialize.\\n    /// @custom:network-specific\\n    address public challenger;\\n\\n    /// @notice The address of the proposer. Can be updated via reinitialize.\\n    /// @custom:network-specific\\n    address public proposer;\\n\\n    /// @notice Emitted when an output is proposed.\\n    /// @param outputRoot    The output root.\\n    /// @param l2OutputIndex The index of the output in the l2Outputs array.\\n    /// @param l2BlockNumber The L2 block number of the output root.\\n    /// @param l1Timestamp   The L1 timestamp when proposed.\\n    event OutputProposed(\\n        bytes32 indexed outputRoot, uint256 indexed l2OutputIndex, uint256 indexed l2BlockNumber, uint256 l1Timestamp\\n    );\\n\\n    /// @notice Emitted when outputs are deleted.\\n    /// @param prevNextOutputIndex Next L2 output index before the deletion.\\n    /// @param newNextOutputIndex  Next L2 output index after the deletion.\\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\\n\\n    /// @notice Semantic version -> comment out to activate oasys customized version\\n    /// @custom:semver 1.5.0\\n    string public constant version = \\\"1.5.0\\\";\\n\\n    /// @notice Constructs the L2OutputOracle contract.\\n    /// @param _submissionInterval  Interval in blocks at which checkpoints must be submitted.\\n    /// @param _l2BlockTime         The time per L2 block, in seconds.\\n    /// @param _finalizationPeriodSeconds The amount of time that must pass for an output proposal\\n    //                                    to be considered canonical.\\n    constructor(uint256 _submissionInterval, uint256 _l2BlockTime, uint256 _finalizationPeriodSeconds) {\\n        require(_l2BlockTime > 0, \\\"L2OutputOracle: L2 block time must be greater than 0\\\");\\n        require(_submissionInterval > 0, \\\"L2OutputOracle: submission interval must be greater than 0\\\");\\n\\n        SUBMISSION_INTERVAL = _submissionInterval;\\n        L2_BLOCK_TIME = _l2BlockTime;\\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\\n\\n        initialize({ _startingBlockNumber: 0, _startingTimestamp: 0, _proposer: address(0), _challenger: address(0) });\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _startingBlockNumber Block number for the first recoded L2 block.\\n    /// @param _startingTimestamp   Timestamp for the first recoded L2 block.\\n    /// @param _proposer            The address of the proposer.\\n    /// @param _challenger          The address of the challenger.\\n    function initialize(\\n        uint256 _startingBlockNumber,\\n        uint256 _startingTimestamp,\\n        address _proposer,\\n        address _challenger\\n    )\\n        // internal  /// @notice visibility is changed from public to internal by oasys custom\\n        public\\n        reinitializer(2)\\n    {\\n        require(\\n            _startingTimestamp <= block.timestamp,\\n            \\\"L2OutputOracle: starting L2 timestamp must be less than current time\\\"\\n        );\\n\\n        startingTimestamp = _startingTimestamp;\\n        startingBlockNumber = _startingBlockNumber;\\n        proposer = _proposer;\\n        challenger = _challenger;\\n    }\\n\\n    /// @notice Getter for the output proposal submission interval.\\n    function submissionInterval() external view returns (uint256) {\\n        return SUBMISSION_INTERVAL;\\n    }\\n\\n    /// @notice Getter for the L2 block time.\\n    function l2BlockTime() external view returns (uint256) {\\n        return L2_BLOCK_TIME;\\n    }\\n\\n    /// @notice Getter for the finalization period.\\n    function finalizationPeriodSeconds() external view returns (uint256) {\\n        return FINALIZATION_PERIOD_SECONDS;\\n    }\\n\\n    /// @notice Getter for the challenger address. This will be removed\\n    ///         in the future, use `challenger` instead.\\n    /// @custom:legacy\\n    function CHALLENGER() external view returns (address) {\\n        return challenger;\\n    }\\n\\n    /// @notice Getter for the proposer address. This will be removed in the\\n    ///         future, use `proposer` instead.\\n    /// @custom:legacy\\n    function PROPOSER() external view returns (address) {\\n        return proposer;\\n    }\\n\\n    /// @notice Deletes all output proposals after and including the proposal that corresponds to\\n    ///         the given output index. Only the challenger address can delete outputs.\\n    /// @param _l2OutputIndex Index of the first L2 output to be deleted.\\n    ///                       All outputs after this output will also be deleted.\\n    // solhint-disable-next-line ordering\\n    function deleteL2Outputs(uint256 _l2OutputIndex) external {\\n        require(msg.sender == challenger, \\\"L2OutputOracle: only the challenger address can delete outputs\\\");\\n\\n        // Make sure we're not *increasing* the length of the array.\\n        require(\\n            _l2OutputIndex < l2Outputs.length, \\\"L2OutputOracle: cannot delete outputs after the latest output index\\\"\\n        );\\n\\n        // Do not allow deleting any outputs that have already been finalized.\\n        require(\\n            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < FINALIZATION_PERIOD_SECONDS,\\n            \\\"L2OutputOracle: cannot delete outputs that have already been finalized\\\"\\n        );\\n\\n        uint256 prevNextL2OutputIndex = nextOutputIndex();\\n\\n        // Use assembly to delete the array elements because Solidity doesn't allow it.\\n        assembly {\\n            sstore(l2Outputs.slot, _l2OutputIndex)\\n        }\\n\\n        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\\n    }\\n\\n    /// @notice Accepts an outputRoot and the timestamp of the corresponding L2 block.\\n    ///         The timestamp must be equal to the current value returned by `nextTimestamp()` in\\n    ///         order to be accepted. This function may only be called by the Proposer.\\n    /// @param _outputRoot    The L2 output of the checkpoint block.\\n    /// @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\\n    /// @param _l1BlockHash   A block hash which must be included in the current chain.\\n    /// @param _l1BlockNumber The block number with the specified block hash.\\n    function proposeL2Output(\\n        bytes32 _outputRoot,\\n        uint256 _l2BlockNumber,\\n        bytes32 _l1BlockHash,\\n        uint256 _l1BlockNumber\\n    )\\n        public virtual /// @notice visibility is chenged from external to override by oasys custom\\n        payable\\n    {\\n        require(msg.sender == proposer, \\\"L2OutputOracle: only the proposer address can propose new outputs\\\");\\n\\n        require(\\n            _l2BlockNumber == nextBlockNumber(),\\n            \\\"L2OutputOracle: block number must be equal to next expected block number\\\"\\n        );\\n\\n        require(\\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\\n            \\\"L2OutputOracle: cannot propose L2 output in the future\\\"\\n        );\\n\\n        require(_outputRoot != bytes32(0), \\\"L2OutputOracle: L2 output proposal cannot be the zero hash\\\");\\n\\n        if (_l1BlockHash != bytes32(0)) {\\n            // This check allows the proposer to propose an output based on a given L1 block,\\n            // without fear that it will be reorged out.\\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\\n            // attack in which the proposer's submission is censored until the block is no longer\\n            // retrievable, if the proposer is experiencing this attack it can simply leave out the\\n            // blockhash value, and delay submission until it is confident that the L1 block is\\n            // finalized.\\n            require(\\n                blockhash(_l1BlockNumber) == _l1BlockHash,\\n                \\\"L2OutputOracle: block hash does not match the hash at the expected height\\\"\\n            );\\n        }\\n\\n        emit OutputProposed(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\\n\\n        l2Outputs.push(\\n            Types.OutputProposal({\\n                outputRoot: _outputRoot,\\n                timestamp: uint128(block.timestamp),\\n                l2BlockNumber: uint128(_l2BlockNumber)\\n            })\\n        );\\n    }\\n\\n    /// @notice Returns an output by index. Needed to return a struct instead of a tuple.\\n    /// @param _l2OutputIndex Index of the output to return.\\n    /// @return The output at the given index.\\n    function getL2Output(uint256 _l2OutputIndex) external view returns (Types.OutputProposal memory) {\\n        return l2Outputs[_l2OutputIndex];\\n    }\\n\\n    /// @notice Returns the index of the L2 output that checkpoints a given L2 block number.\\n    ///         Uses a binary search to find the first output greater than or equal to the given\\n    ///         block.\\n    /// @param _l2BlockNumber L2 block number to find a checkpoint for.\\n    /// @return Index of the first checkpoint that commits to the given L2 block number.\\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\\n        // Make sure an output for this block number has actually been proposed.\\n        require(\\n            _l2BlockNumber <= latestBlockNumber(),\\n            \\\"L2OutputOracle: cannot get output for a block that has not been proposed\\\"\\n        );\\n\\n        // Make sure there's at least one output proposed.\\n        require(l2Outputs.length > 0, \\\"L2OutputOracle: cannot get output as no outputs have been proposed yet\\\");\\n\\n        // Find the output via binary search, guaranteed to exist.\\n        uint256 lo = 0;\\n        uint256 hi = l2Outputs.length;\\n        while (lo < hi) {\\n            uint256 mid = (lo + hi) / 2;\\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    /// @notice Returns the L2 output proposal that checkpoints a given L2 block number.\\n    ///         Uses a binary search to find the first output greater than or equal to the given\\n    ///         block.\\n    /// @param _l2BlockNumber L2 block number to find a checkpoint for.\\n    /// @return First checkpoint that commits to the given L2 block number.\\n    function getL2OutputAfter(uint256 _l2BlockNumber) external view returns (Types.OutputProposal memory) {\\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\\n    }\\n\\n    /// @notice Returns the number of outputs that have been proposed.\\n    ///         Will revert if no outputs have been proposed yet.\\n    /// @return The number of outputs that have been proposed.\\n    function latestOutputIndex() external view returns (uint256) {\\n        return l2Outputs.length - 1;\\n    }\\n\\n    /// @notice Returns the index of the next output to be proposed.\\n    /// @return The index of the next output to be proposed.\\n    function nextOutputIndex() public view returns (uint256) {\\n        return l2Outputs.length;\\n    }\\n\\n    /// @notice Returns the block number of the latest submitted L2 output proposal.\\n    ///         If no proposals been submitted yet then this function will return the starting\\n    ///         block number.\\n    /// @return Latest submitted L2 block number.\\n    function latestBlockNumber() public view returns (uint256) {\\n        return l2Outputs.length == 0 ? startingBlockNumber : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\\n    }\\n\\n    /// @notice Computes the block number of the next L2 block that needs to be checkpointed.\\n    /// @return Next L2 block number.\\n    function nextBlockNumber() public view returns (uint256) {\\n        return latestBlockNumber() + SUBMISSION_INTERVAL;\\n    }\\n\\n    /// @notice Returns the L2 timestamp corresponding to a given L2 block number.\\n    /// @param _l2BlockNumber The L2 block number of the target block.\\n    /// @return L2 timestamp of the given block.\\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\\n    }\\n}\\n\",\"keccak256\":\"0x92485a667bb4a41017f37dc5fcb67e0e52310a94d97b558e900fb9221c379e66\",\"license\":\"MIT\"},\"contracts/L1/OptimismPortal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { L2OutputOracle } from \\\"./L2OutputOracle.sol\\\";\\nimport { SystemConfig } from \\\"./SystemConfig.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\nimport { Types } from \\\"../libraries/Types.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { SecureMerkleTrie } from \\\"../libraries/trie/SecureMerkleTrie.sol\\\";\\nimport { AddressAliasHelper } from \\\"../vendor/AddressAliasHelper.sol\\\";\\nimport { ResourceMetering } from \\\"./ResourceMetering.sol\\\";\\nimport { ISemver } from \\\"../universal/ISemver.sol\\\";\\n\\n/// @custom:proxied\\n/// @title OptimismPortal\\n/// @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\\n///         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\\n///         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\\ncontract OptimismPortal is Initializable, ResourceMetering, ISemver {\\n    /// @notice Represents a proven withdrawal.\\n    /// @custom:field outputRoot    Root of the L2 output this was proven against.\\n    /// @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\\n    /// @custom:field l2OutputIndex Index of the output this was proven against.\\n    struct ProvenWithdrawal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2OutputIndex;\\n    }\\n\\n    /// @notice Version of the deposit event.\\n    uint256 internal constant DEPOSIT_VERSION = 0;\\n\\n    /// @notice The L2 gas limit set when eth is deposited using the receive() function.\\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\\n\\n    /// @notice Address of the L2 account which initiated a withdrawal in this transaction.\\n    ///         If the of this variable is the default L2 sender address, then we are NOT inside of\\n    ///         a call to finalizeWithdrawalTransaction.\\n    address public l2Sender;\\n\\n    /// @notice A list of withdrawal hashes which have been successfully finalized.\\n    mapping(bytes32 => bool) public finalizedWithdrawals;\\n\\n    /// @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\\n\\n    /// @notice Determines if cross domain messaging is paused.\\n    ///         When set to true, withdrawals are paused.\\n    ///         This may be removed in the future.\\n    bool public paused;\\n\\n    /// @notice Address of the L2OutputOracle contract.\\n    /// @custom:network-specific\\n    L2OutputOracle public l2Oracle;\\n\\n    /// @notice Address of the SystemConfig contract.\\n    /// @custom:network-specific\\n    SystemConfig public systemConfig;\\n\\n    /// @notice Address that has the ability to pause and unpause withdrawals.\\n    /// @custom:network-specific\\n    address public guardian;\\n\\n    /// @notice Emitted when a transaction is deposited from L1 to L2.\\n    ///         The parameters of this event are read by the rollup node and used to derive deposit\\n    ///         transactions on L2.\\n    /// @param from       Address that triggered the deposit transaction.\\n    /// @param to         Address that the deposit transaction is directed to.\\n    /// @param version    Version of this deposit transaction event.\\n    /// @param opaqueData ABI encoded deposit data to be parsed off-chain.\\n    event TransactionDeposited(address indexed from, address indexed to, uint256 indexed version, bytes opaqueData);\\n\\n    /// @notice Emitted when a withdrawal transaction is proven.\\n    /// @param withdrawalHash Hash of the withdrawal transaction.\\n    /// @param from           Address that triggered the withdrawal transaction.\\n    /// @param to             Address that the withdrawal transaction is directed to.\\n    event WithdrawalProven(bytes32 indexed withdrawalHash, address indexed from, address indexed to);\\n\\n    /// @notice Emitted when a withdrawal transaction is finalized.\\n    /// @param withdrawalHash Hash of the withdrawal transaction.\\n    /// @param success        Whether the withdrawal transaction was successful.\\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\\n\\n    /// @notice Emitted when the pause is triggered.\\n    /// @param account Address of the account triggering the pause.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted.\\n    /// @param account Address of the account triggering the unpause.\\n    event Unpaused(address account);\\n\\n    /// @notice Reverts when paused.\\n    modifier whenNotPaused() {\\n        require(paused == false, \\\"OptimismPortal: paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 1.9.0\\n    string public constant version = \\\"1.9.0\\\";\\n\\n    /// @notice Constructs the OptimismPortal contract.\\n    constructor() {\\n        initialize({\\n            _l2Oracle: L2OutputOracle(address(0)),\\n            _guardian: address(0),\\n            _systemConfig: SystemConfig(address(0)),\\n            _paused: true\\n        });\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _l2Oracle Address of the L2OutputOracle contract.\\n    /// @param _guardian Address that can pause withdrawals.\\n    /// @param _paused Sets the contract's pausability state.\\n    /// @param _systemConfig Address of the SystemConfig contract.\\n    function initialize(\\n        L2OutputOracle _l2Oracle,\\n        address _guardian,\\n        SystemConfig _systemConfig,\\n        bool _paused\\n    )\\n        public\\n        reinitializer(2)\\n    {\\n        l2Sender = Constants.DEFAULT_L2_SENDER;\\n        l2Oracle = _l2Oracle;\\n        systemConfig = _systemConfig;\\n        guardian = _guardian;\\n        paused = _paused;\\n        __ResourceMetering_init();\\n    }\\n\\n    /// @notice Getter for the L2OutputOracle\\n    /// @custom:legacy\\n    function L2_ORACLE() external view returns (L2OutputOracle) {\\n        return l2Oracle;\\n    }\\n\\n    /// @notice Getter for the SystemConfig\\n    /// @custom:legacy\\n    function SYSTEM_CONFIG() external view returns (SystemConfig) {\\n        return systemConfig;\\n    }\\n\\n    /// @notice Getter for the Guardian\\n    /// @custom:legacy\\n    function GUARDIAN() external view returns (address) {\\n        return guardian;\\n    }\\n\\n    /// @notice Pauses withdrawals.\\n    function pause() external {\\n        require(msg.sender == guardian, \\\"OptimismPortal: only guardian can pause\\\");\\n        paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /// @notice Unpauses withdrawals.\\n    function unpause() external {\\n        require(msg.sender == guardian, \\\"OptimismPortal: only guardian can unpause\\\");\\n        paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /// @notice Computes the minimum gas limit for a deposit.\\n    ///         The minimum gas limit linearly increases based on the size of the calldata.\\n    ///         This is to prevent users from creating L2 resource usage without paying for it.\\n    ///         This function can be used when interacting with the portal to ensure forwards\\n    ///         compatibility.\\n    /// @param _byteCount Number of bytes in the calldata.\\n    /// @return The minimum gas limit for a deposit.\\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\\n        return _byteCount * 16 + 21000;\\n    }\\n\\n    /// @notice Accepts value so that users can send ETH directly to this contract and have the\\n    ///         funds be deposited to their address on L2. This is intended as a convenience\\n    ///         function for EOAs. Contracts should call the depositTransaction() function directly\\n    ///         otherwise any deposited funds will be lost due to address aliasing.\\n    // solhint-disable-next-line ordering\\n    receive() external payable {\\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\\\"\\\"));\\n    }\\n\\n    /// @notice Accepts ETH value without triggering a deposit to L2.\\n    ///         This function mainly exists for the sake of the migration between the legacy\\n    ///         Optimism system and Bedrock.\\n    function donateETH() external payable {\\n        // Intentionally empty.\\n    }\\n\\n    /// @notice Getter for the resource config.\\n    ///         Used internally by the ResourceMetering contract.\\n    ///         The SystemConfig is the source of truth for the resource config.\\n    /// @return ResourceMetering ResourceConfig\\n    function _resourceConfig() internal view override returns (ResourceMetering.ResourceConfig memory) {\\n        return systemConfig.resourceConfig();\\n    }\\n\\n    /// @notice Proves a withdrawal transaction.\\n    /// @param _tx              Withdrawal transaction to finalize.\\n    /// @param _l2OutputIndex   L2 output index to prove against.\\n    /// @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\\n    /// @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\\n    function proveWithdrawalTransaction(\\n        Types.WithdrawalTransaction memory _tx,\\n        uint256 _l2OutputIndex,\\n        Types.OutputRootProof calldata _outputRootProof,\\n        bytes[] calldata _withdrawalProof\\n    )\\n        external\\n        whenNotPaused\\n    {\\n        // Prevent users from creating a deposit transaction where this address is the message\\n        // sender on L2. Because this is checked here, we do not need to check again in\\n        // `finalizeWithdrawalTransaction`.\\n        require(_tx.target != address(this), \\\"OptimismPortal: you cannot send messages to the portal contract\\\");\\n\\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\\n        // revert if there is no output root for the given block number.\\n        bytes32 outputRoot = l2Oracle.getL2Output(_l2OutputIndex).outputRoot;\\n\\n        // Verify that the output root can be generated with the elements in the proof.\\n        require(\\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof), \\\"OptimismPortal: invalid output root proof\\\"\\n        );\\n\\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\\n\\n        // We generally want to prevent users from proving the same withdrawal multiple times\\n        // because each successive proof will update the timestamp. A malicious user can take\\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\\n        // since withdrawals are proven before an output root is finalized, we need to allow users\\n        // to re-prove their withdrawal only in the case that the output root for their specified\\n        // output index has been updated.\\n        require(\\n            provenWithdrawal.timestamp == 0\\n                || l2Oracle.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot != provenWithdrawal.outputRoot,\\n            \\\"OptimismPortal: withdrawal hash has already been proven\\\"\\n        );\\n\\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\\n        // Refer to the Solidity documentation for more information on how storage layouts are\\n        // computed for mappings.\\n        bytes32 storageKey = keccak256(\\n            abi.encode(\\n                withdrawalHash,\\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\\n            )\\n        );\\n\\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\\n        // be relayed on L1.\\n        require(\\n            SecureMerkleTrie.verifyInclusionProof(\\n                abi.encode(storageKey), hex\\\"01\\\", _withdrawalProof, _outputRootProof.messagePasserStorageRoot\\n            ),\\n            \\\"OptimismPortal: invalid withdrawal inclusion proof\\\"\\n        );\\n\\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\\n        // proven once unless it is submitted again with a different outputRoot.\\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\\n            outputRoot: outputRoot,\\n            timestamp: uint128(block.timestamp),\\n            l2OutputIndex: uint128(_l2OutputIndex)\\n        });\\n\\n        // Emit a `WithdrawalProven` event.\\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\\n    }\\n\\n    /// @notice Finalizes a withdrawal transaction.\\n    /// @param _tx Withdrawal transaction to finalize.\\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx) external whenNotPaused {\\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\\n        // than the default value when a withdrawal transaction is being finalized. This check is\\n        // a defacto reentrancy guard.\\n        require(\\n            l2Sender == Constants.DEFAULT_L2_SENDER, \\\"OptimismPortal: can only trigger one withdrawal per transaction\\\"\\n        );\\n\\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\\n\\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\\n        // a timestamp of zero.\\n        require(provenWithdrawal.timestamp != 0, \\\"OptimismPortal: withdrawal has not been proven yet\\\");\\n\\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\\n        // safety against weird bugs in the proving step.\\n        require(\\n            provenWithdrawal.timestamp >= l2Oracle.startingTimestamp(),\\n            \\\"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\\\"\\n        );\\n\\n        // A proven withdrawal must wait at least the finalization period before it can be\\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\\n        // output the withdrawal was proven against. In effect, this means that the minimum\\n        // withdrawal time is proposal submission time + finalization period.\\n        require(\\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\\n            \\\"OptimismPortal: proven withdrawal finalization period has not elapsed\\\"\\n        );\\n\\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\\n        // corresponds to the given index has not been proposed yet.\\n        Types.OutputProposal memory proposal = l2Oracle.getL2Output(provenWithdrawal.l2OutputIndex);\\n\\n        // Check that the output root that was used to prove the withdrawal is the same as the\\n        // current output root for the given output index. An output root may change if it is\\n        // deleted by the challenger address and then re-proposed.\\n        require(\\n            proposal.outputRoot == provenWithdrawal.outputRoot,\\n            \\\"OptimismPortal: output root proven is not the same as current output root\\\"\\n        );\\n\\n        // Check that the output proposal has also been finalized.\\n        require(\\n            _isFinalizationPeriodElapsed(proposal.timestamp),\\n            \\\"OptimismPortal: output proposal finalization period has not elapsed\\\"\\n        );\\n\\n        // Check that this withdrawal has not already been finalized, this is replay protection.\\n        require(finalizedWithdrawals[withdrawalHash] == false, \\\"OptimismPortal: withdrawal has already been finalized\\\");\\n\\n        // Mark the withdrawal as finalized so it can't be replayed.\\n        finalizedWithdrawals[withdrawalHash] = true;\\n\\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\\n        l2Sender = _tx.sender;\\n\\n        // Trigger the call to the target contract. We use a custom low level method\\n        // SafeCall.callWithMinGas to ensure two key properties\\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\\n        //      amount of data (and this is OK because we don't care about the returndata here).\\n        //   2. The amount of gas provided to the execution context of the target is at least the\\n        //      gas limit specified by the user. If there is not enough gas in the current context\\n        //      to accomplish this, `callWithMinGas` will revert.\\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\\n\\n        // Reset the l2Sender back to the default value.\\n        l2Sender = Constants.DEFAULT_L2_SENDER;\\n\\n        // All withdrawals are immediately finalized. Replayability can\\n        // be achieved through contracts built on top of this contract\\n        emit WithdrawalFinalized(withdrawalHash, success);\\n\\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\\n        // sub call to the target contract if the minimum gas limit specified by the user would not\\n        // be sufficient to execute the sub call.\\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\\n            revert(\\\"OptimismPortal: withdrawal failed\\\");\\n        }\\n    }\\n\\n    /// @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\\n    ///         deriving deposit transactions. Note that if a deposit is made by a contract, its\\n    ///         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\\n    ///         using the CrossDomainMessenger contracts for a simpler developer experience.\\n    /// @param _to         Target address on L2.\\n    /// @param _value      ETH value to send to the recipient.\\n    /// @param _gasLimit   Amount of L2 gas to purchase by burning gas on L1.\\n    /// @param _isCreation Whether or not the transaction is a contract creation.\\n    /// @param _data       Data to trigger the recipient with.\\n    function depositTransaction(\\n        address _to,\\n        uint256 _value,\\n        uint64 _gasLimit,\\n        bool _isCreation,\\n        bytes memory _data\\n    )\\n        public\\n        payable\\n        metered(_gasLimit)\\n    {\\n        // Just to be safe, make sure that people specify address(0) as the target when doing\\n        // contract creations.\\n        if (_isCreation) {\\n            require(_to == address(0), \\\"OptimismPortal: must send to address(0) when creating a contract\\\");\\n        }\\n\\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\\n        // more for more resource usage.\\n        require(_gasLimit >= minimumGasLimit(uint64(_data.length)), \\\"OptimismPortal: gas limit too small\\\");\\n\\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\\n        // transactions are not gossipped over the p2p network.\\n        require(_data.length <= 120_000, \\\"OptimismPortal: data too large\\\");\\n\\n        // Transform the from-address to its alias if the caller is a contract.\\n        address from = msg.sender;\\n        if (msg.sender != tx.origin) {\\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\\n        // We use opaque data so that we can update the TransactionDeposited event in the future\\n        // without breaking the current interface.\\n        bytes memory opaqueData = abi.encodePacked(msg.value, _value, _gasLimit, _isCreation, _data);\\n\\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\\n        // transaction for this deposit.\\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\\n    }\\n\\n    /// @notice Determine if a given output is finalized.\\n    ///         Reverts if the call to L2_ORACLE.getL2Output reverts.\\n    ///         Returns a boolean otherwise.\\n    /// @param _l2OutputIndex Index of the L2 output to check.\\n    /// @return Whether or not the output is finalized.\\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\\n        return _isFinalizationPeriodElapsed(l2Oracle.getL2Output(_l2OutputIndex).timestamp);\\n    }\\n\\n    /// @notice Determines whether the finalization period has elapsed with respect to\\n    ///         the provided block timestamp.\\n    /// @param _timestamp Timestamp to check.\\n    /// @return Whether or not the finalization period has elapsed.\\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\\n        return block.timestamp > _timestamp + l2Oracle.FINALIZATION_PERIOD_SECONDS();\\n    }\\n}\\n\",\"keccak256\":\"0x81b34c59a3fa39e243c5361909c157ea5bbd105ff6c1060090973de083125635\",\"license\":\"MIT\"},\"contracts/L1/ResourceMetering.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { Burn } from \\\"../libraries/Burn.sol\\\";\\nimport { Arithmetic } from \\\"../libraries/Arithmetic.sol\\\";\\n\\n/// @custom:upgradeable\\n/// @title ResourceMetering\\n/// @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\\n///         updates automatically based on current demand.\\nabstract contract ResourceMetering is Initializable {\\n    /// @notice Represents the various parameters that control the way in which resources are\\n    ///         metered. Corresponds to the EIP-1559 resource metering system.\\n    /// @custom:field prevBaseFee   Base fee from the previous block(s).\\n    /// @custom:field prevBoughtGas Amount of gas bought so far in the current block.\\n    /// @custom:field prevBlockNum  Last block number that the base fee was updated.\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    /// @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\\n    ///         market. These values should be set with care as it is possible to set them in\\n    ///         a way that breaks the deposit gas market. The target resource limit is defined as\\n    ///         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\\n    ///         single word. There is additional space for additions in the future.\\n    /// @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\\n    ///                                            can be purchased per block.\\n    /// @custom:field elasticityMultiplier         Determines the target resource limit along with\\n    ///                                            the resource limit.\\n    /// @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\\n    /// @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\\n    ///                                            value.\\n    /// @custom:field systemTxMaxGas               The amount of gas supplied to the system\\n    ///                                            transaction. This should be set to the same\\n    ///                                            number that the op-node sets as the gas limit\\n    ///                                            for the system transaction.\\n    /// @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\\n    ///                                            value.\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    /// @notice EIP-1559 style gas parameters.\\n    ResourceParams public params;\\n\\n    /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n    uint256[48] private __gap;\\n\\n    /// @notice Meters access to a function based an amount of a requested resource.\\n    /// @param _amount Amount of the resource requested.\\n    modifier metered(uint64 _amount) {\\n        // Record initial gas amount so we can refund for it later.\\n        uint256 initialGas = gasleft();\\n\\n        // Run the underlying function.\\n        _;\\n\\n        // Run the metering function.\\n        _metered(_amount, initialGas);\\n    }\\n\\n    /// @notice An internal function that holds all of the logic for metering a resource.\\n    /// @param _amount     Amount of the resource requested.\\n    /// @param _initialGas The amount of gas before any modifier execution.\\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\\n        // Update block number and base fee if necessary.\\n        uint256 blockDiff = block.number - params.prevBlockNum;\\n\\n        ResourceConfig memory config = _resourceConfig();\\n        int256 targetResourceLimit =\\n            int256(uint256(config.maxResourceLimit)) / int256(uint256(config.elasticityMultiplier));\\n\\n        if (blockDiff > 0) {\\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\\n            // at which deposits can be created and therefore limit the potential for deposits to\\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta)\\n                / (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\\n\\n            // Update base fee by adding the base fee delta and clamp the resulting value between\\n            // min and max.\\n            int256 newBaseFee = Arithmetic.clamp({\\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\\n                _min: int256(uint256(config.minimumBaseFee)),\\n                _max: int256(uint256(config.maximumBaseFee))\\n            });\\n\\n            // If we skipped more than one block, we also need to account for every empty block.\\n            // Empty block means there was no demand for deposits in that block, so we should\\n            // reflect this lack of demand in the fee.\\n            if (blockDiff > 1) {\\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\\n                // between min and max.\\n                newBaseFee = Arithmetic.clamp({\\n                    _value: Arithmetic.cdexp({\\n                        _coefficient: newBaseFee,\\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\\n                        _exponent: int256(blockDiff - 1)\\n                    }),\\n                    _min: int256(uint256(config.minimumBaseFee)),\\n                    _max: int256(uint256(config.maximumBaseFee))\\n                });\\n            }\\n\\n            // Update new base fee, reset bought gas, and update block number.\\n            params.prevBaseFee = uint128(uint256(newBaseFee));\\n            params.prevBoughtGas = 0;\\n            params.prevBlockNum = uint64(block.number);\\n        }\\n\\n        // Make sure we can actually buy the resource amount requested by the user.\\n        params.prevBoughtGas += _amount;\\n        require(\\n            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),\\n            \\\"ResourceMetering: cannot buy more gas than available gas limit\\\"\\n        );\\n\\n        // Determine the amount of ETH to be paid.\\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\\n\\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\\n        // during any 1 day period in the last 5 years, so should be fine.\\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\\n\\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\\n        // effectively like a dynamic stipend (with a minimum value).\\n        uint256 usedGas = _initialGas - gasleft();\\n        if (gasCost > usedGas) {\\n            Burn.gas(gasCost - usedGas);\\n        }\\n    }\\n\\n    /// @notice Virtual function that returns the resource config.\\n    ///         Contracts that inherit this contract must implement this function.\\n    /// @return ResourceConfig\\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\\n\\n    /// @notice Sets initial resource parameter values.\\n    ///         This function must either be called by the initializer function of an upgradeable\\n    ///         child contract.\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __ResourceMetering_init() internal onlyInitializing {\\n        params = ResourceParams({ prevBaseFee: 1 gwei, prevBoughtGas: 0, prevBlockNum: uint64(block.number) });\\n    }\\n}\\n\",\"keccak256\":\"0xcbdb44713cb15af4c542ef51f2be9e32da0bb4ffc72a03953b38870955023fc3\",\"license\":\"MIT\"},\"contracts/L1/SystemConfig.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { OwnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { ISemver } from \\\"../universal/ISemver.sol\\\";\\nimport { ResourceMetering } from \\\"./ResourceMetering.sol\\\";\\n\\n/// @title SystemConfig\\n/// @notice The SystemConfig contract is used to manage configuration of an Optimism network.\\n///         All configuration is stored on L1 and picked up by L2 as part of the derviation of\\n///         the L2 chain.\\ncontract SystemConfig is OwnableUpgradeable, ISemver {\\n    /// @notice Enum representing different types of updates.\\n    /// @custom:value BATCHER              Represents an update to the batcher hash.\\n    /// @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.\\n    /// @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\\n    /// @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\\n    ///                                    block distrubution.\\n    enum UpdateType {\\n        BATCHER,\\n        GAS_CONFIG,\\n        GAS_LIMIT,\\n        UNSAFE_BLOCK_SIGNER\\n    }\\n\\n    /// @notice Struct representing the addresses of L1 system contracts. These should be the\\n    ///         proxies and will differ for each OP Stack chain.\\n    struct Addresses {\\n        address l1CrossDomainMessenger;\\n        address l1ERC721Bridge;\\n        address l1StandardBridge;\\n        address l2OutputOracle;\\n        address optimismPortal;\\n        address optimismMintableERC20Factory;\\n    }\\n\\n    /// @notice Version identifier, used for upgrades.\\n    uint256 public constant VERSION = 0;\\n\\n    /// @notice Storage slot that the unsafe block signer is stored at.\\n    ///         Storing it at this deterministic storage slot allows for decoupling the storage\\n    ///         layout from the way that `solc` lays out storage. The `op-node` uses a storage\\n    ///         proof to fetch this value.\\n    /// @dev    NOTE: this value will be migrated to another storage slot in a future version.\\n    ///         User input should not be placed in storage in this contract until this migration\\n    ///         happens. It is unlikely that keccak second preimage resistance will be broken,\\n    ///         but it is better to be safe than sorry.\\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\\\"systemconfig.unsafeblocksigner\\\");\\n\\n    /// @notice Storage slot that the L1CrossDomainMessenger address is stored at.\\n    bytes32 public constant L1_CROSS_DOMAIN_MESSENGER_SLOT =\\n        bytes32(uint256(keccak256(\\\"systemconfig.l1crossdomainmessenger\\\")) - 1);\\n\\n    /// @notice Storage slot that the L1ERC721Bridge address is stored at.\\n    bytes32 public constant L1_ERC_721_BRIDGE_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.l1erc721bridge\\\")) - 1);\\n\\n    /// @notice Storage slot that the L1StandardBridge address is stored at.\\n    bytes32 public constant L1_STANDARD_BRIDGE_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.l1standardbridge\\\")) - 1);\\n\\n    /// @notice Storage slot that the L2OutputOracle address is stored at.\\n    bytes32 public constant L2_OUTPUT_ORACLE_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.l2outputoracle\\\")) - 1);\\n\\n    /// @notice Storage slot that the OptimismPortal address is stored at.\\n    bytes32 public constant OPTIMISM_PORTAL_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.optimismportal\\\")) - 1);\\n\\n    /// @notice Storage slot that the OptimismMintableERC20Factory address is stored at.\\n    bytes32 public constant OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT =\\n        bytes32(uint256(keccak256(\\\"systemconfig.optimismmintableerc20factory\\\")) - 1);\\n\\n    /// @notice Storage slot that the batch inbox address is stored at.\\n    bytes32 public constant BATCH_INBOX_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.batchinbox\\\")) - 1);\\n\\n    /// @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\\n    uint256 public overhead;\\n\\n    /// @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\\n    uint256 public scalar;\\n\\n    /// @notice Identifier for the batcher.\\n    ///         For version 1 of this configuration, this is represented as an address left-padded\\n    ///         with zeros to 32 bytes.\\n    bytes32 public batcherHash;\\n\\n    /// @notice L2 block gas limit.\\n    uint64 public gasLimit;\\n\\n    /// @notice The configuration for the deposit fee market.\\n    ///         Used by the OptimismPortal to meter the cost of buying L2 gas on L1.\\n    ///         Set as internal with a getter so that the struct is returned instead of a tuple.\\n    ResourceMetering.ResourceConfig internal _resourceConfig;\\n\\n    /// @notice Emitted when configuration is updated.\\n    /// @param version    SystemConfig version.\\n    /// @param updateType Type of update.\\n    /// @param data       Encoded update data.\\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\\n\\n    /// @notice The block at which the op-node can start searching for logs from.\\n    uint256 public startBlock;\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 1.7.0\\n    string public constant version = \\\"1.7.0\\\";\\n\\n    /// @notice Constructs the SystemConfig contract. Cannot set\\n    ///         the owner to `address(0)` due to the Ownable contract's\\n    ///         implementation, so set it to `address(0xdEaD)`\\n    constructor() {\\n        initialize({\\n            _owner: address(0xdEaD),\\n            _overhead: 0,\\n            _scalar: 0,\\n            _batcherHash: bytes32(0),\\n            _gasLimit: 1,\\n            _unsafeBlockSigner: address(0),\\n            _config: ResourceMetering.ResourceConfig({\\n                maxResourceLimit: 1,\\n                elasticityMultiplier: 1,\\n                baseFeeMaxChangeDenominator: 2,\\n                minimumBaseFee: 0,\\n                systemTxMaxGas: 0,\\n                maximumBaseFee: 0\\n            }),\\n            _startBlock: type(uint256).max,\\n            _batchInbox: address(0),\\n            _addresses: SystemConfig.Addresses({\\n                l1CrossDomainMessenger: address(0),\\n                l1ERC721Bridge: address(0),\\n                l1StandardBridge: address(0),\\n                l2OutputOracle: address(0),\\n                optimismPortal: address(0),\\n                optimismMintableERC20Factory: address(0)\\n            })\\n        });\\n    }\\n\\n    /// @notice Initializer.\\n    ///         The resource config must be set before the require check.\\n    /// @param _owner             Initial owner of the contract.\\n    /// @param _overhead          Initial overhead value.\\n    /// @param _scalar            Initial scalar value.\\n    /// @param _batcherHash       Initial batcher hash.\\n    /// @param _gasLimit          Initial gas limit.\\n    /// @param _unsafeBlockSigner Initial unsafe block signer address.\\n    /// @param _config            Initial ResourceConfig.\\n    /// @param _startBlock        Starting block for the op-node to search for logs from.\\n    ///                           Contracts that were deployed before this field existed\\n    ///                           need to have this field set manually via an override.\\n    ///                           Newly deployed contracts should set this value to uint256(0).\\n    /// @param _batchInbox        Batch inbox address. An identifier for the op-node to find\\n    ///                           canonical data.\\n    /// @param _addresses         Set of L1 contract addresses. These should be the proxies.\\n    function initialize(\\n        address _owner,\\n        uint256 _overhead,\\n        uint256 _scalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        address _unsafeBlockSigner,\\n        ResourceMetering.ResourceConfig memory _config,\\n        uint256 _startBlock,\\n        address _batchInbox,\\n        SystemConfig.Addresses memory _addresses\\n    )\\n        public\\n        reinitializer(2)\\n    {\\n        __Ownable_init();\\n        transferOwnership(_owner);\\n\\n        // These are set in ascending order of their UpdateTypes.\\n        _setBatcherHash(_batcherHash);\\n        _setGasConfig({ _overhead: _overhead, _scalar: _scalar });\\n        _setGasLimit(_gasLimit);\\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\\n\\n        _setAddress(_batchInbox, BATCH_INBOX_SLOT);\\n        _setAddress(_addresses.l1CrossDomainMessenger, L1_CROSS_DOMAIN_MESSENGER_SLOT);\\n        _setAddress(_addresses.l1ERC721Bridge, L1_ERC_721_BRIDGE_SLOT);\\n        _setAddress(_addresses.l1StandardBridge, L1_STANDARD_BRIDGE_SLOT);\\n        _setAddress(_addresses.l2OutputOracle, L2_OUTPUT_ORACLE_SLOT);\\n        _setAddress(_addresses.optimismPortal, OPTIMISM_PORTAL_SLOT);\\n        _setAddress(_addresses.optimismMintableERC20Factory, OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT);\\n\\n        _setStartBlock(_startBlock);\\n\\n        _setResourceConfig(_config);\\n        require(_gasLimit >= minimumGasLimit(), \\\"SystemConfig: gas limit too low\\\");\\n    }\\n\\n    /// @notice Returns the minimum L2 gas limit that can be safely set for the system to\\n    ///         operate. The L2 gas limit must be larger than or equal to the amount of\\n    ///         gas that is allocated for deposits per block plus the amount of gas that\\n    ///         is allocated for the system transaction.\\n    ///         This function is used to determine if changes to parameters are safe.\\n    /// @return uint64 Minimum gas limit.\\n    function minimumGasLimit() public view returns (uint64) {\\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\\n    }\\n\\n    /// @notice High level getter for the unsafe block signer address.\\n    ///         Unsafe blocks can be propagated across the p2p network if they are signed by the\\n    ///         key corresponding to this address.\\n    /// @return addr_ Address of the unsafe block signer.\\n    // solhint-disable-next-line ordering\\n    function unsafeBlockSigner() external view returns (address addr_) {\\n        addr_ = _getAddress(UNSAFE_BLOCK_SIGNER_SLOT);\\n    }\\n\\n    /// @notice Stores an address in an arbitrary storage slot, `_slot`.\\n    /// @param _addr The address to store\\n    /// @param _slot The storage slot to store the address in.\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots. Solc will add checks that the data passed as `_addr`\\n    ///      is 20 bytes or less.\\n    function _setAddress(address _addr, bytes32 _slot) internal {\\n        assembly {\\n            sstore(_slot, _addr)\\n        }\\n    }\\n\\n    /// @notice Returns an address stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function _getAddress(bytes32 _slot) internal view returns (address addr_) {\\n        assembly {\\n            addr_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Getter for the L1CrossDomainMessenger address.\\n    function l1CrossDomainMessenger() external view returns (address addr_) {\\n        addr_ = _getAddress(L1_CROSS_DOMAIN_MESSENGER_SLOT);\\n    }\\n\\n    /// @notice Getter for the L1ERC721Bridge address.\\n    function l1ERC721Bridge() external view returns (address addr_) {\\n        addr_ = _getAddress(L1_ERC_721_BRIDGE_SLOT);\\n    }\\n\\n    /// @notice Getter for the L1StandardBridge address.\\n    function l1StandardBridge() external view returns (address addr_) {\\n        addr_ = _getAddress(L1_STANDARD_BRIDGE_SLOT);\\n    }\\n\\n    /// @notice Getter for the L2OutputOracle address.\\n    function l2OutputOracle() external view returns (address addr_) {\\n        addr_ = _getAddress(L2_OUTPUT_ORACLE_SLOT);\\n    }\\n\\n    /// @notice Getter for the OptimismPortal address.\\n    function optimismPortal() external view returns (address addr_) {\\n        addr_ = _getAddress(OPTIMISM_PORTAL_SLOT);\\n    }\\n\\n    /// @notice Getter for the OptimismMintableERC20Factory address.\\n    function optimismMintableERC20Factory() external view returns (address addr_) {\\n        addr_ = _getAddress(OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT);\\n    }\\n\\n    /// @notice Getter for the BatchInbox address.\\n    function batchInbox() external view returns (address addr_) {\\n        addr_ = _getAddress(BATCH_INBOX_SLOT);\\n    }\\n\\n    /// @notice Sets the start block in a backwards compatible way. Proxies\\n    ///         that were initialized before the startBlock existed in storage\\n    ///         can have their start block set by a user provided override.\\n    ///         A start block of 0 indicates that there is no override and the\\n    ///         start block will be set by `block.number`.\\n    /// @dev    This logic is used to patch legacy with new storage values. In the\\n    ///         next version, it should remove the override and set the start block\\n    ///         to `block.number` if the value in storage is 0. This will allow it\\n    ///         to be reinitialized again and also work for fresh deployments.\\n    /// @param  _startBlock The start block override to set in storage.\\n    function _setStartBlock(uint256 _startBlock) internal {\\n        require(startBlock == 0, \\\"SystemConfig: cannot override an already set start block\\\");\\n        if (_startBlock != 0) {\\n            // There is an override, it cannot already be set.\\n            startBlock = _startBlock;\\n        } else {\\n            // There is no override and it is not set in storage. Set it to the block number.\\n            startBlock = block.number;\\n        }\\n    }\\n\\n    /// @notice Updates the unsafe block signer address. Can only be called by the owner.\\n    /// @param _unsafeBlockSigner New unsafe block signer address.\\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\\n    }\\n\\n    /// @notice Updates the unsafe block signer address.\\n    /// @param _unsafeBlockSigner New unsafe block signer address.\\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\\n        _setAddress(_unsafeBlockSigner, UNSAFE_BLOCK_SIGNER_SLOT);\\n\\n        bytes memory data = abi.encode(_unsafeBlockSigner);\\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\\n    }\\n\\n    /// @notice Updates the batcher hash. Can only be called by the owner.\\n    /// @param _batcherHash New batcher hash.\\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\\n        _setBatcherHash(_batcherHash);\\n    }\\n\\n    /// @notice Internal function for updating the batcher hash.\\n    /// @param _batcherHash New batcher hash.\\n    function _setBatcherHash(bytes32 _batcherHash) internal {\\n        batcherHash = _batcherHash;\\n\\n        bytes memory data = abi.encode(_batcherHash);\\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\\n    }\\n\\n    /// @notice Updates gas config. Can only be called by the owner.\\n    /// @param _overhead New overhead value.\\n    /// @param _scalar   New scalar value.\\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\\n        _setGasConfig(_overhead, _scalar);\\n    }\\n\\n    /// @notice Internal function for updating the gas config.\\n    /// @param _overhead New overhead value.\\n    /// @param _scalar   New scalar value.\\n    function _setGasConfig(uint256 _overhead, uint256 _scalar) internal {\\n        overhead = _overhead;\\n        scalar = _scalar;\\n\\n        bytes memory data = abi.encode(_overhead, _scalar);\\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\\n    }\\n\\n    /// @notice Updates the L2 gas limit. Can only be called by the owner.\\n    /// @param _gasLimit New gas limit.\\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\\n        _setGasLimit(_gasLimit);\\n    }\\n\\n    /// @notice Internal function for updating the L2 gas limit.\\n    /// @param _gasLimit New gas limit.\\n    function _setGasLimit(uint64 _gasLimit) internal {\\n        require(_gasLimit >= minimumGasLimit(), \\\"SystemConfig: gas limit too low\\\");\\n        gasLimit = _gasLimit;\\n\\n        bytes memory data = abi.encode(_gasLimit);\\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\\n    }\\n\\n    /// @notice A getter for the resource config.\\n    ///         Ensures that the struct is returned instead of a tuple.\\n    /// @return ResourceConfig\\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\\n        return _resourceConfig;\\n    }\\n\\n    /// @notice An external setter for the resource config.\\n    ///         In the future, this method may emit an event that the `op-node` picks up\\n    ///         for when the resource config is changed.\\n    /// @param _config The new resource config values.\\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\\n        _setResourceConfig(_config);\\n    }\\n\\n    /// @notice An internal setter for the resource config.\\n    ///         Ensures that the config is sane before storing it by checking for invariants.\\n    /// @param _config The new resource config.\\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\\n        // Min base fee must be less than or equal to max base fee.\\n        require(\\n            _config.minimumBaseFee <= _config.maximumBaseFee, \\\"SystemConfig: min base fee must be less than max base\\\"\\n        );\\n        // Base fee change denominator must be greater than 1.\\n        require(_config.baseFeeMaxChangeDenominator > 1, \\\"SystemConfig: denominator must be larger than 1\\\");\\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\\n        // The gas limit must be increased before these values can be increased.\\n        require(_config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit, \\\"SystemConfig: gas limit too low\\\");\\n        // Elasticity multiplier must be greater than 0.\\n        require(_config.elasticityMultiplier > 0, \\\"SystemConfig: elasticity multiplier cannot be 0\\\");\\n        // No precision loss when computing target resource limit.\\n        require(\\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) * _config.elasticityMultiplier)\\n                == _config.maxResourceLimit,\\n            \\\"SystemConfig: precision loss with target resource limit\\\"\\n        );\\n\\n        _resourceConfig = _config;\\n    }\\n}\\n\",\"keccak256\":\"0x4fe81a41bc1c033fc73f75dbae5dbcf87312d05d12f59818aa025653f0d7d05a\",\"license\":\"MIT\"},\"contracts/legacy/AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @custom:legacy\\n/// @title AddressManager\\n/// @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n///         system to manage a registry of string names to addresses. We now use a more standard\\n///         proxy system instead, but this contract is still necessary for backwards compatibility\\n///         with several older contracts.\\ncontract AddressManager is Ownable {\\n    /// @notice Mapping of the hashes of string names to addresses.\\n    mapping(bytes32 => address) private addresses;\\n\\n    /// @notice Emitted when an address is modified in the registry.\\n    /// @param name       String name being set in the registry.\\n    /// @param newAddress Address set for the given name.\\n    /// @param oldAddress Address that was previously set for the given name.\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /// @notice Changes the address associated with a particular name.\\n    /// @param _name    String name to associate an address with.\\n    /// @param _address Address to associate with the name.\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /// @notice Retrieves the address associated with a given name.\\n    /// @param _name Name to retrieve an address for.\\n    /// @return Address associated with the given name.\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /// @notice Computes the hash of a name.\\n    /// @param _name Name to compute a hash for.\\n    /// @return Hash of the given name.\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0x1fcb990df6473f7fa360d5924d62d39ce2ca97d45668e3901e5405cfbe598b19\",\"license\":\"MIT\"},\"contracts/legacy/L1ChugSplashProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\n\\n/// @title IL1ChugSplashDeployer\\ninterface IL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\\n/// @custom:legacy\\n/// @title L1ChugSplashProxy\\n/// @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n///         functions `setCode` and `setStorage` for changing the code or storage of the contract.\\n///         Note for future developers: do NOT make anything in this contract 'public' unless you\\n///         know what you're doing. Anything public can potentially have a function signature that\\n///         conflicts with a signature attached to the implementation contract. Public functions\\n///         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\\n///         reason not to have that modifier. And there almost certainly is not a good reason to not\\n///         have that modifier. Beware!\\ncontract L1ChugSplashProxy {\\n    /// @notice \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a\\n    ///         contract, the appended bytecode will be deployed as given.\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    /// @notice Blocks a function from being called when the parent signals that the system should\\n    ///         be paused via an isUpgrading function.\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) =\\n            owner.staticcall(abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector));\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice Makes a proxy call instead of triggering the given function when the caller is\\n    ///         either the owner or the zero address. Caller can only ever be the zero address if\\n    ///         this function is being called off-chain via eth_call, which is totally fine and can\\n    ///         be convenient for client-side tooling. Avoids situations where the proxy and\\n    ///         implementation share a sighash and the proxy function ends up being called instead\\n    ///         of the implementation one.\\n    ///         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\\n    ///         there's a way for someone to send a transaction with msg.sender == address(0) in any\\n    ///         real context then we have much bigger problems. Primary reason to include this\\n    ///         additional allowed sender is because the owner address can be changed dynamically\\n    ///         and we do not want clients to have to keep track of the current owner in order to\\n    ///         make an eth_call that doesn't trigger the proxied contract.\\n    // slither-disable-next-line incorrect-modifier\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /// @param _owner Address of the initial contract owner.\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /// @notice Sets the code that should be running behind this proxy.\\n    ///         Note: This scheme is a bit different from the standard proxy scheme where one would\\n    ///         typically deploy the code separately and then set the implementation address. We're\\n    ///         doing it this way because it gives us a lot more freedom on the client side. Can\\n    ///         only be triggered by the contract owner.\\n    /// @param _code New contract code to run inside this contract.\\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /// @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\\n    ///         perform upgrades in a more transparent way. Only callable by the owner.\\n    /// @param _key   Storage key to modify.\\n    /// @param _value New value for the storage key.\\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract. Only callable by the owner.\\n    /// @param _owner New owner of the proxy contract.\\n    function setOwner(address _owner) external proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /// @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\\n    ///         making an eth_call and setting the \\\"from\\\" address to address(0).\\n    /// @return Owner address.\\n    function getOwner() external proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /// @notice Queries the implementation address. Can only be called by the owner OR by making an\\n    ///         eth_call and setting the \\\"from\\\" address to address(0).\\n    /// @return Implementation address.\\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /// @notice Sets the implementation address.\\n    /// @param _implementation New implementation address.\\n    function _setImplementation(address _implementation) internal {\\n        bytes32 proxyImplementation = Constants.PROXY_IMPLEMENTATION_ADDRESS;\\n        assembly {\\n            sstore(proxyImplementation, _implementation)\\n        }\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract.\\n    /// @param _owner New owner of the proxy contract.\\n    function _setOwner(address _owner) internal {\\n        bytes32 proxyOwner = Constants.PROXY_OWNER_ADDRESS;\\n        assembly {\\n            sstore(proxyOwner, _owner)\\n        }\\n    }\\n\\n    /// @notice Performs the proxy call via a delegatecall.\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) { revert(0x0, returndatasize()) }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /// @notice Queries the implementation address.\\n    /// @return Implementation address.\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        bytes32 proxyImplementation = Constants.PROXY_IMPLEMENTATION_ADDRESS;\\n        assembly {\\n            implementation := sload(proxyImplementation)\\n        }\\n        return implementation;\\n    }\\n\\n    /// @notice Queries the owner of the proxy contract.\\n    /// @return Owner address.\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        bytes32 proxyOwner = Constants.PROXY_OWNER_ADDRESS;\\n        assembly {\\n            owner := sload(proxyOwner)\\n        }\\n        return owner;\\n    }\\n\\n    /// @notice Gets the code hash for a given account.\\n    /// @param _account Address of the account to get a code hash for.\\n    /// @return Code hash for the account.\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n}\\n\",\"keccak256\":\"0xf8fd3adf2d45c5fd6b28ce16ecaf5d119b1567fefe4a78dcd3f551e412c4c4d6\",\"license\":\"MIT\"},\"contracts/libraries/Arithmetic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { SignedMath } from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\n/// @title Arithmetic\\n/// @notice Even more math than before.\\nlibrary Arithmetic {\\n    /// @notice Clamps a value between a minimum and maximum.\\n    /// @param _value The value to clamp.\\n    /// @param _min   The minimum value.\\n    /// @param _max   The maximum value.\\n    /// @return The clamped value.\\n    function clamp(int256 _value, int256 _min, int256 _max) internal pure returns (int256) {\\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\\n    }\\n\\n    /// @notice (c)oefficient (d)enominator (exp)onentiation function.\\n    ///         Returns the result of: c * (1 - 1/d)^exp.\\n    /// @param _coefficient Coefficient of the function.\\n    /// @param _denominator Fractional denominator.\\n    /// @param _exponent    Power function exponent.\\n    /// @return Result of c * (1 - 1/d)^exp.\\n    function cdexp(int256 _coefficient, int256 _denominator, int256 _exponent) internal pure returns (int256) {\\n        return (_coefficient * (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\\n    }\\n}\\n\",\"keccak256\":\"0x06a5a8b00527843f0cfc1bb3c0661316966a6cc432f88be31f23cde78cd07560\",\"license\":\"MIT\"},\"contracts/libraries/Burn.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @title Burn\\n/// @notice Utilities for burning stuff.\\nlibrary Burn {\\n    /// @notice Burns a given amount of ETH.\\n    /// @param _amount Amount of ETH to burn.\\n    function eth(uint256 _amount) internal {\\n        new Burner{ value: _amount }();\\n    }\\n\\n    /// @notice Burns a given amount of gas.\\n    /// @param _amount Amount of gas to burn.\\n    function gas(uint256 _amount) internal view {\\n        uint256 i = 0;\\n        uint256 initialGas = gasleft();\\n        while (initialGas - gasleft() < _amount) {\\n            ++i;\\n        }\\n    }\\n}\\n\\n/// @title Burner\\n/// @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\\n///         the contract from the circulating supply. Self-destructing is the only way to remove ETH\\n///         from the circulating supply.\\ncontract Burner {\\n    constructor() payable {\\n        selfdestruct(payable(address(this)));\\n    }\\n}\\n\",\"keccak256\":\"0x90a795bcea3ef06d6d5011256c4bd63d1a4271f519246dbf1ee3e8f1c0e21010\",\"license\":\"MIT\"},\"contracts/libraries/Bytes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Bytes\\n/// @notice Bytes is a library for manipulating byte arrays.\\nlibrary Bytes {\\n    /// @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\\n    /// @notice Slices a byte array with a given starting index and length. Returns a new byte array\\n    ///         as opposed to a pointer to the original array. Will throw if trying to slice more\\n    ///         bytes than exist in the array.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @param _length Length of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        unchecked {\\n            require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n            require(_start + _length >= _start, \\\"slice_overflow\\\");\\n            require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } { mstore(mc, mload(cc)) }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// @notice Slices a byte array with a given starting index up to the end of the original byte\\n    ///         array. Returns a new array rathern than a pointer to the original.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    /// @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\\n    ///         Resulting nibble array will be exactly twice as long as the input byte array.\\n    /// @param _bytes Input byte array to convert.\\n    /// @return Resulting nibble array.\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory _nibbles;\\n        assembly {\\n            // Grab a free memory offset for the new array\\n            _nibbles := mload(0x40)\\n\\n            // Load the length of the passed bytes array from memory\\n            let bytesLength := mload(_bytes)\\n\\n            // Calculate the length of the new nibble array\\n            // This is the length of the input array times 2\\n            let nibblesLength := shl(0x01, bytesLength)\\n\\n            // Update the free memory pointer to allocate memory for the new array.\\n            // To do this, we add the length of the new array + 32 bytes for the array length\\n            // rounded up to the nearest 32 byte boundary to the current free memory pointer.\\n            mstore(0x40, add(_nibbles, and(not(0x1F), add(nibblesLength, 0x3F))))\\n\\n            // Store the length of the new array in memory\\n            mstore(_nibbles, nibblesLength)\\n\\n            // Store the memory offset of the _bytes array's contents on the stack\\n            let bytesStart := add(_bytes, 0x20)\\n\\n            // Store the memory offset of the nibbles array's contents on the stack\\n            let nibblesStart := add(_nibbles, 0x20)\\n\\n            // Loop through each byte in the input array\\n            for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {\\n                // Get the starting offset of the next 2 bytes in the nibbles array\\n                let offset := add(nibblesStart, shl(0x01, i))\\n                // Load the byte at the current index within the `_bytes` array\\n                let b := byte(0x00, mload(add(bytesStart, i)))\\n\\n                // Pull out the first nibble and store it in the new array\\n                mstore8(offset, shr(0x04, b))\\n                // Pull out the second nibble and store it in the new array\\n                mstore8(add(offset, 0x01), and(b, 0x0F))\\n            }\\n        }\\n        return _nibbles;\\n    }\\n\\n    /// @notice Compares two byte arrays by comparing their keccak256 hashes.\\n    /// @param _bytes First byte array to compare.\\n    /// @param _other Second byte array to compare.\\n    /// @return True if the two byte arrays are equal, false otherwise.\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0x827f47d123b0fdf3b08816d5b33831811704dbf4e554e53f2269354f6bba8859\",\"license\":\"MIT\"},\"contracts/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ResourceMetering } from \\\"../L1/ResourceMetering.sol\\\";\\n\\n/// @title Constants\\n/// @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\\n///         the stuff used in multiple contracts. Constants that only apply to a single contract\\n///         should be defined in that contract instead.\\nlibrary Constants {\\n    /// @notice Special address to be used as the tx origin for gas estimation calls in the\\n    ///         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\\n    ///         the minimum gas limit specified by the user is not actually enough to execute the\\n    ///         given message and you're attempting to estimate the actual necessary gas limit. We\\n    ///         use address(1) because it's the ecrecover precompile and therefore guaranteed to\\n    ///         never have any code on any EVM chain.\\n    address internal constant ESTIMATION_ADDRESS = address(1);\\n\\n    /// @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\\n    ///         CrossDomainMessenger contracts before an actual sender is set. This value is\\n    ///         non-zero to reduce the gas cost of message passing transactions.\\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\\n\\n    /// @notice The storage slot that holds the address of a proxy implementation.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\\n    bytes32 internal constant PROXY_IMPLEMENTATION_ADDRESS =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice The storage slot that holds the address of the owner.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`\\n    bytes32 internal constant PROXY_OWNER_ADDRESS = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Returns the default values for the ResourceConfig. These are the recommended values\\n    ///         for a production network.\\n    function DEFAULT_RESOURCE_CONFIG() internal pure returns (ResourceMetering.ResourceConfig memory) {\\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\\n            maxResourceLimit: 20_000_000,\\n            elasticityMultiplier: 10,\\n            baseFeeMaxChangeDenominator: 8,\\n            minimumBaseFee: 1 gwei,\\n            systemTxMaxGas: 1_000_000,\\n            maximumBaseFee: type(uint128).max\\n        });\\n        return config;\\n    }\\n}\\n\",\"keccak256\":\"0x8fcbc468fa4924f81538d4a6674031e12b62b61a88e869fdf099158a0d0c6a19\",\"license\":\"MIT\"},\"contracts/libraries/Encoding.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\nimport { Hashing } from \\\"./Hashing.sol\\\";\\nimport { RLPWriter } from \\\"./rlp/RLPWriter.sol\\\";\\n\\n/// @title Encoding\\n/// @notice Encoding handles Optimism's various different encoding schemes.\\nlibrary Encoding {\\n    /// @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\\n    ///         to the L2 system. Useful for searching for a deposit in the L2 system. The\\n    ///         transaction is prefixed with 0x7e to identify its EIP-2718 type.\\n    /// @param _tx User deposit transaction to encode.\\n    /// @return RLP encoded L2 deposit transaction.\\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes memory) {\\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\\n        bytes[] memory raw = new bytes[](8);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\\n        raw[1] = RLPWriter.writeAddress(_tx.from);\\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\\\"\\\") : RLPWriter.writeAddress(_tx.to);\\n        raw[3] = RLPWriter.writeUint(_tx.mint);\\n        raw[4] = RLPWriter.writeUint(_tx.value);\\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\\n        raw[6] = RLPWriter.writeBool(false);\\n        raw[7] = RLPWriter.writeBytes(_tx.data);\\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\\n    }\\n\\n    /// @notice Encodes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        (, uint16 version) = decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Encoding: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodeWithSignature(\\\"relayMessage(address,address,bytes,uint256)\\\", _target, _sender, _data, _nonce);\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodeWithSignature(\\n            \\\"relayMessage(uint256,address,address,uint256,uint256,bytes)\\\",\\n            _nonce,\\n            _sender,\\n            _target,\\n            _value,\\n            _gasLimit,\\n            _data\\n        );\\n    }\\n\\n    /// @notice Adds a version number into the first two bytes of a message nonce.\\n    /// @param _nonce   Message nonce to encode into.\\n    /// @param _version Version number to encode into the message nonce.\\n    /// @return Message nonce with version encoded into the first two bytes.\\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\\n        uint256 nonce;\\n        assembly {\\n            nonce := or(shl(240, _version), _nonce)\\n        }\\n        return nonce;\\n    }\\n\\n    /// @notice Pulls the version out of a version-encoded nonce.\\n    /// @param _nonce Message nonce with version encoded into the first two bytes.\\n    /// @return Nonce without encoded version.\\n    /// @return Version of the message.\\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\\n        uint240 nonce;\\n        uint16 version;\\n        assembly {\\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            version := shr(240, _nonce)\\n        }\\n        return (nonce, version);\\n    }\\n}\\n\",\"keccak256\":\"0xd5bbcb7da113e69562498d9543765e03912558ad66348682c2049c31e19f9d9b\",\"license\":\"MIT\"},\"contracts/libraries/Hashing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\nimport { Encoding } from \\\"./Encoding.sol\\\";\\n\\n/// @title Hashing\\n/// @notice Hashing handles Optimism's various different hashing schemes.\\nlibrary Hashing {\\n    /// @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\\n    ///         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\\n    ///         system.\\n    /// @param _tx User deposit transaction to hash.\\n    /// @return Hash of the RLP encoded L2 deposit transaction.\\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\\n    }\\n\\n    /// @notice Computes the deposit transaction's \\\"source hash\\\", a value that guarantees the hash\\n    ///         of the L2 transaction that corresponds to a deposit is unique and is\\n    ///         deterministically generated from L1 transaction data.\\n    /// @param _l1BlockHash Hash of the L1 block where the deposit was included.\\n    /// @param _logIndex    The index of the log that created the deposit transaction.\\n    /// @return Hash of the deposit transaction's \\\"source hash\\\".\\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex) internal pure returns (bytes32) {\\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\\n        return keccak256(abi.encode(bytes32(0), depositId));\\n    }\\n\\n    /// @notice Hashes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Hashing: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data));\\n    }\\n\\n    /// @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\\n    /// @param _tx Withdrawal transaction to hash.\\n    /// @return Hashed withdrawal transaction.\\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data));\\n    }\\n\\n    /// @notice Hashes the various elements of an output root proof into an output root hash which\\n    ///         can be used to check if the proof is valid.\\n    /// @param _outputRootProof Output root proof which should hash to an output root.\\n    /// @return Hashed output root proof.\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _outputRootProof.version,\\n                _outputRootProof.stateRoot,\\n                _outputRootProof.messagePasserStorageRoot,\\n                _outputRootProof.latestBlockhash\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x44e2b2dcfffc39c0fc95ccd3c2118c7e7585fadf3dca327877d5756c7d4b21c3\",\"license\":\"MIT\"},\"contracts/libraries/Predeploys.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Predeploys\\n/// @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\\nlibrary Predeploys {\\n    /// @notice Address of the L2ToL1MessagePasser predeploy.\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\\n\\n    /// @notice Address of the L2CrossDomainMessenger predeploy.\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\\n\\n    /// @notice Address of the L2StandardBridge predeploy.\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n\\n    /// @notice Address of the L2ERC721Bridge predeploy.\\n    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\\n\\n    //// @notice Address of the SequencerFeeWallet predeploy.\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n\\n    /// @notice Address of the OptimismMintableERC20Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY = 0x4200000000000000000000000000000000000012;\\n\\n    /// @notice Address of the OptimismMintableERC721Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY = 0x4200000000000000000000000000000000000017;\\n\\n    /// @notice Address of the L1Block predeploy.\\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\\n\\n    /// @notice Address of the GasPriceOracle predeploy. Includes fee information\\n    ///         and helpers for computing the L1 portion of the transaction fee.\\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\\n    ///         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the DeployerWhitelist predeploy. No longer active.\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\\n    ///         state trie as of the Bedrock upgrade. Contract has been locked and write functions\\n    ///         can no longer be accessed.\\n    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\\n    ///         instead, which exposes more information about the L1 state.\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\\n    ///         L2ToL1MessagePasser contract instead.\\n    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n\\n    /// @notice Address of the ProxyAdmin predeploy.\\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\\n\\n    /// @notice Address of the BaseFeeVault predeploy.\\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\\n\\n    /// @notice Address of the L1FeeVault predeploy.\\n    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\\n\\n    /// @notice Address of the GovernanceToken predeploy.\\n    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\\n\\n    /// @notice Address of the SchemaRegistry predeploy.\\n    address internal constant SCHEMA_REGISTRY = 0x4200000000000000000000000000000000000020;\\n\\n    /// @notice Address of the EAS predeploy.\\n    address internal constant EAS = 0x4200000000000000000000000000000000000021;\\n}\\n\",\"keccak256\":\"0x5af3a849f68f7c9108858ebac5c769da8f1c0309b5c0cb42eb5cbb15e3fe6058\",\"license\":\"MIT\"},\"contracts/libraries/SafeCall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @title SafeCall\\n/// @notice Perform low level safe calls\\nlibrary SafeCall {\\n    /// @notice Performs a low level call without copying any returndata.\\n    /// @dev Passes no calldata to the call context.\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _gas, uint256 _value) internal returns (bool) {\\n        bool _success;\\n        assembly {\\n            _success :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    0, // inloc\\n                    0, // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, uint256 _gas, uint256 _value, bytes memory _calldata) internal returns (bool) {\\n        bool _success;\\n        assembly {\\n            _success :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n\\n    /// @notice Helper function to determine if there is sufficient gas remaining within the context\\n    ///         to guarantee that the minimum gas requirement for a call will be met as well as\\n    ///         optionally reserving a specified amount of gas for after the call has concluded.\\n    /// @param _minGas      The minimum amount of gas that may be passed to the target context.\\n    /// @param _reservedGas Optional amount of gas to reserve for the caller after the execution\\n    ///                     of the target context.\\n    /// @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\\n    ///         context as well as reserve `_reservedGas` for the caller after the execution of\\n    ///         the target context.\\n    /// @dev !!!!! FOOTGUN ALERT !!!!!\\n    ///      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\\n    ///          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\\n    ///          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\\n    ///          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\\n    ///          that does not account for the `memory_expansion_cost` & `code_execution_cost`\\n    ///          factors of the dynamic cost of the `CALL` opcode.\\n    ///      2.) This function should *directly* precede the external call if possible. There is an\\n    ///          added buffer to account for gas consumed between this check and the call, but it\\n    ///          is only 5,700 gas.\\n    ///      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\\n    ///          frame may be passed to a subcontext, we need to ensure that the gas will not be\\n    ///          truncated.\\n    ///      4.) Use wisely. This function is not a silver bullet.\\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\\n        bool _hasMinGas;\\n        assembly {\\n            // Equation: gas \\u00d7 63 \\u2265 minGas \\u00d7 64 + 63(40_000 + reservedGas)\\n            _hasMinGas := iszero(lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63))))\\n        }\\n        return _hasMinGas;\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata. This function\\n    ///         will revert if the call cannot be performed with the specified minimum\\n    ///         gas.\\n    /// @param _target   Address to call\\n    /// @param _minGas   The minimum amount of gas that may be passed to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function callWithMinGas(\\n        address _target,\\n        uint256 _minGas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool _success;\\n        bool _hasMinGas = hasMinGas(_minGas, 0);\\n        assembly {\\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\\n            if iszero(_hasMinGas) {\\n                // Store the \\\"Error(string)\\\" selector in scratch space.\\n                mstore(0, 0x08c379a0)\\n                // Store the pointer to the string length in scratch space.\\n                mstore(32, 32)\\n                // Store the string.\\n                //\\n                // SAFETY:\\n                // - We pad the beginning of the string with two zero bytes as well as the\\n                // length (24) to ensure that we override the free memory pointer at offset\\n                // 0x40. This is necessary because the free memory pointer is likely to\\n                // be greater than 1 byte when this function is called, but it is incredibly\\n                // unlikely that it will be greater than 3 bytes. As for the data within\\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\\n                // - It's fine to clobber the free memory pointer, we're reverting.\\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\\n\\n                // Revert with 'Error(\\\"SafeCall: Not enough gas\\\")'\\n                revert(28, 100)\\n            }\\n\\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\\n            // above assertion. This ensures that, in all circumstances (except for when the\\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\\n            // the minimum amount of gas specified.\\n            _success :=\\n                call(\\n                    gas(), // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0x00, // outloc\\n                    0x00 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n}\\n\",\"keccak256\":\"0x0636a7abb242bb5d6f5606967c8929e6aa7e63468c1e2ce40ad4780d4c4bf94f\",\"license\":\"MIT\"},\"contracts/libraries/Types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Types\\n/// @notice Contains various types used throughout the Optimism contract system.\\nlibrary Types {\\n    /// @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n    ///         timestamp that the output root is posted. This timestamp is used to verify that the\\n    ///         finalization period has passed since the output root was submitted.\\n    /// @custom:field outputRoot    Hash of the L2 output.\\n    /// @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n    /// @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /// @notice Struct representing the elements that are hashed together to generate an output root\\n    ///         which itself represents a snapshot of the L2 state.\\n    /// @custom:field version                  Version of the output root.\\n    /// @custom:field stateRoot                Root of the state trie at the block of this output.\\n    /// @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n    /// @custom:field latestBlockhash          Hash of the block this output was generated from.\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /// @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n    ///         user (as opposed to a system deposit transaction generated by the system).\\n    /// @custom:field from        Address of the sender of the transaction.\\n    /// @custom:field to          Address of the recipient of the transaction.\\n    /// @custom:field isCreation  True if the transaction is a contract creation.\\n    /// @custom:field value       Value to send to the recipient.\\n    /// @custom:field mint        Amount of ETH to mint.\\n    /// @custom:field gasLimit    Gas limit of the transaction.\\n    /// @custom:field data        Data of the transaction.\\n    /// @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n    /// @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 value;\\n        uint256 mint;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /// @notice Struct representing a withdrawal transaction.\\n    /// @custom:field nonce    Nonce of the withdrawal transaction\\n    /// @custom:field sender   Address of the sender of the transaction.\\n    /// @custom:field target   Address of the recipient of the transaction.\\n    /// @custom:field value    Value to send to the recipient.\\n    /// @custom:field gasLimit Gas limit of the transaction.\\n    /// @custom:field data     Data of the transaction.\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 value;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n}\\n\",\"keccak256\":\"0x75900d651301940d24c00d14f0b3b6cbd6dcf379173ceaa31d9bf5be934a9aa4\",\"license\":\"MIT\"},\"contracts/libraries/rlp/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @custom:attribution https://github.com/hamdiallam/Solidity-RLP\\n/// @title RLPReader\\n/// @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\\n///         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\\n///         various tweaks to improve readability.\\nlibrary RLPReader {\\n    /// @notice Custom pointer type to avoid confusion between pointers and uint256s.\\n    type MemoryPointer is uint256;\\n\\n    /// @notice RLP item types.\\n    /// @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\\n    /// @custom:value LIST_ITEM Represents an RLP list item.\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /// @notice Struct representing an RLP item.\\n    /// @custom:field length Length of the RLP item.\\n    /// @custom:field ptr    Pointer to the RLP item in memory.\\n    struct RLPItem {\\n        uint256 length;\\n        MemoryPointer ptr;\\n    }\\n\\n    /// @notice Max list length that this library will accept.\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /// @notice Converts bytes to a reference to memory position and length.\\n    /// @param _in Input bytes to convert.\\n    /// @return out_ Output memory reference.\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {\\n        // Empty arrays are not RLP items.\\n        require(_in.length > 0, \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\");\\n\\n        MemoryPointer ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        out_ = RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {\\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"RLPReader: decoded item type for list is not a list item\\\");\\n\\n        require(listOffset + listLength == _in.length, \\\"RLPReader: list item has an invalid data remainder\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        out_ = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            (uint256 itemOffset, uint256 itemLength,) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset) })\\n            );\\n\\n            // We don't need to check itemCount < out.length explicitly because Solidity already\\n            // handles this check on our behalf, we'd just be wasting gas.\\n            out_[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out_, itemCount)\\n        }\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {\\n        out_ = readList(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"RLPReader: decoded item type for bytes is not a data item\\\");\\n\\n        require(_in.length == itemOffset + itemLength, \\\"RLPReader: bytes value contains an invalid remainder\\\");\\n\\n        out_ = _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        out_ = readBytes(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads the raw bytes of an RLP item.\\n    /// @param _in RLP item to read.\\n    /// @return out_ Raw RLP bytes.\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        out_ = _copy(_in.ptr, 0, _in.length);\\n    }\\n\\n    /// @notice Decodes the length of an RLP item.\\n    /// @param _in RLP item to decode.\\n    /// @return offset_ Offset of the encoded data.\\n    /// @return length_ Length of the encoded data.\\n    /// @return type_ RLP item type (LIST_ITEM or DATA_ITEM).\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (uint256 offset_, uint256 length_, RLPItemType type_)\\n    {\\n        // Short-circuit if there's nothing to decode, note that we perform this check when\\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\\n        // that function and create an RLP item directly. So we need to check this anyway.\\n        require(_in.length > 0, \\\"RLPReader: length of an RLP item must be greater than zero to be decodable\\\");\\n\\n        MemoryPointer ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen, \\\"RLPReader: length of content must be greater than string length (short string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                strLen != 1 || firstByteOfContent >= 0x80,\\n                \\\"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"RLPReader: length of content must be > than length of string length (long string)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00, \\\"RLPReader: length of content must not have any leading zeros (long string)\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(strLen > 55, \\\"RLPReader: length of content must be greater than 55 bytes (long string)\\\");\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"RLPReader: length of content must be greater than total length (long string)\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"RLPReader: length of content must be greater than list length (short list)\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"RLPReader: length of content must be > than length of list length (long list)\\\"\\n            );\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            require(\\n                firstByteOfContent != 0x00, \\\"RLPReader: length of content must not have any leading zeros (long list)\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\\n            }\\n\\n            require(listLen > 55, \\\"RLPReader: length of content must be greater than 55 bytes (long list)\\\");\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"RLPReader: length of content must be greater than total length (long list)\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /// @notice Copies the bytes from a memory location.\\n    /// @param _src    Pointer to the location to read from.\\n    /// @param _offset Offset to start reading from.\\n    /// @param _length Number of bytes to read.\\n    /// @return out_ Copied bytes.\\n    function _copy(MemoryPointer _src, uint256 _offset, uint256 _length) private pure returns (bytes memory out_) {\\n        out_ = new bytes(_length);\\n        if (_length == 0) {\\n            return out_;\\n        }\\n\\n        // Mostly based on Solidity's copy_memory_to_memory:\\n        // solhint-disable max-line-length\\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\\n        assembly {\\n            let dest := add(out_, 32)\\n            let i := 0\\n            for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }\\n\\n            if gt(i, _length) { mstore(add(dest, _length), 0) }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9ba74a3b0a11693e622380807d213d5d1250d974e18b2cd768da9cbe719a6778\",\"license\":\"MIT\"},\"contracts/libraries/rlp/RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n/// @title RLPWriter\\n/// @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n///         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n///         modifications to improve legibility.\\nlibrary RLPWriter {\\n    /// @notice RLP encodes a byte string.\\n    /// @param _in The byte string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            out_ = _in;\\n        } else {\\n            out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n    }\\n\\n    /// @notice RLP encodes a list of RLP encoded byte byte strings.\\n    /// @param _in The list of RLP encoded byte strings.\\n    /// @return list_ The RLP encoded list of items in bytes.\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory list_) {\\n        list_ = _flatten(_in);\\n        list_ = abi.encodePacked(_writeLength(list_.length, 192), list_);\\n    }\\n\\n    /// @notice RLP encodes a string.\\n    /// @param _in The string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeString(string memory _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(bytes(_in));\\n    }\\n\\n    /// @notice RLP encodes an address.\\n    /// @param _in The address to encode.\\n    /// @return out_ The RLP encoded address in bytes.\\n    function writeAddress(address _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /// @notice RLP encodes a uint.\\n    /// @param _in The uint256 to encode.\\n    /// @return out_ The RLP encoded uint256 in bytes.\\n    function writeUint(uint256 _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(_toBinary(_in));\\n    }\\n\\n    /// @notice RLP encodes a bool.\\n    /// @param _in The bool to encode.\\n    /// @return out_ The RLP encoded bool in bytes.\\n    function writeBool(bool _in) internal pure returns (bytes memory out_) {\\n        out_ = new bytes(1);\\n        out_[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n    }\\n\\n    /// @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n    /// @param _len    The length of the string or the payload.\\n    /// @param _offset 128 if item is string, 192 if item is list.\\n    /// @return out_ RLP encoded bytes.\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) {\\n        if (_len < 56) {\\n            out_ = new bytes(1);\\n            out_[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            out_ = new bytes(lenLen + 1);\\n            out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n    }\\n\\n    /// @notice Encode integer in big endian binary form with no leading zeroes.\\n    /// @param _x The integer to encode.\\n    /// @return out_ RLP encoded bytes.\\n    function _toBinary(uint256 _x) private pure returns (bytes memory out_) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        out_ = new bytes(32 - i);\\n        for (uint256 j = 0; j < out_.length; j++) {\\n            out_[j] = b[i++];\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n    /// @notice Copies a piece of memory to another location.\\n    /// @param _dest Destination location.\\n    /// @param _src  Source location.\\n    /// @param _len  Length of memory to copy.\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n    /// @notice Flattens a list of byte strings into one byte string.\\n    /// @param _list List of byte strings to flatten.\\n    /// @return out_ The flattened byte string.\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory out_) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        out_ = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(out_, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x60ac401490f321c9c55e996a2c65151cd5e60de5f8f297e7c94d541c29820bb6\",\"license\":\"MIT\"},\"contracts/libraries/trie/MerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Bytes } from \\\"../Bytes.sol\\\";\\nimport { RLPReader } from \\\"../rlp/RLPReader.sol\\\";\\n\\n/// @title MerkleTrie\\n/// @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\\n///         inclusion proofs. By default, this library assumes a hexary trie. One can change the\\n///         trie radix constant to support other trie radixes.\\nlibrary MerkleTrie {\\n    /// @notice Struct representing a node in the trie.\\n    /// @custom:field encoded The RLP-encoded node.\\n    /// @custom:field decoded The RLP-decoded node.\\n    struct TrieNode {\\n        bytes encoded;\\n        RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /// @notice Determines the number of elements per branch node.\\n    uint256 internal constant TREE_RADIX = 16;\\n\\n    /// @notice Branch nodes have TREE_RADIX elements and one value element.\\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n\\n    /// @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    /// @notice Prefix for even-nibbled extension node paths.\\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\\n\\n    /// @notice Prefix for odd-nibbled extension node paths.\\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\\n\\n    /// @notice Prefix for even-nibbled leaf node paths.\\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\\n\\n    /// @notice Prefix for odd-nibbled leaf node paths.\\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\\n\\n    /// @notice Verifies a proof that a given key/value pair is present in the trie.\\n    /// @param _key   Key of the node to search for, as a hex string.\\n    /// @param _value Value of the node to search for, as a hex string.\\n    /// @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n    ///               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n    ///               nodes that make a path down to the target node.\\n    /// @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n    ///               correctly constructed.\\n    /// @return valid_ Whether or not the proof is valid.\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        valid_ = Bytes.equal(_value, get(_key, _proof, _root));\\n    }\\n\\n    /// @notice Retrieves the value associated with a given key.\\n    /// @param _key   Key to search for, as hex bytes.\\n    /// @param _proof Merkle trie inclusion proof for the key.\\n    /// @param _root  Known root of the Merkle trie.\\n    /// @return value_ Value of the key if it exists.\\n    function get(bytes memory _key, bytes[] memory _proof, bytes32 _root) internal pure returns (bytes memory value_) {\\n        require(_key.length > 0, \\\"MerkleTrie: empty key\\\");\\n\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        bytes memory key = Bytes.toNibbles(_key);\\n        bytes memory currentNodeID = abi.encodePacked(_root);\\n        uint256 currentKeyIndex = 0;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            TrieNode memory currentNode = proof[i];\\n\\n            // Key index should never exceed total key length or we'll be out of bounds.\\n            require(currentKeyIndex <= key.length, \\\"MerkleTrie: key index exceeds total key length\\\");\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid root hash\\\"\\n                );\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 32 bytes aren't hashed.\\n                require(Bytes.equal(currentNode.encoded, currentNodeID), \\\"MerkleTrie: invalid internal node hash\\\");\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // Value is the last element of the decoded list (for branch nodes). There's\\n                    // some ambiguity in the Merkle trie specification because bytes(0) is a\\n                    // valid value to place into the trie, but for branch nodes bytes(0) can exist\\n                    // even when the value wasn't explicitly placed there. Geth treats a value of\\n                    // bytes(0) as \\\"key does not exist\\\" and so we do the same.\\n                    value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);\\n                    require(value_.length > 0, \\\"MerkleTrie: value length must be greater than zero (branch)\\\");\\n\\n                    // Extra proof elements are not allowed.\\n                    require(i == proof.length - 1, \\\"MerkleTrie: value node must be last node in proof (branch)\\\");\\n\\n                    return value_;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIndex += 1;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Bytes.slice(path, offset);\\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                // Whether this is a leaf node or an extension node, the path remainder MUST be a\\n                // prefix of the key remainder (or be equal to the key remainder) or the proof is\\n                // considered invalid.\\n                require(\\n                    pathRemainder.length == sharedNibbleLength,\\n                    \\\"MerkleTrie: path remainder must share all nibbles with key\\\"\\n                );\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,\\n                    // the key remainder must be exactly equal to the path remainder. We already\\n                    // did the necessary byte comparison, so it's more efficient here to check that\\n                    // the key remainder length equals the shared nibble length, which implies\\n                    // equality with the path remainder (since we already did the same check with\\n                    // the path remainder and the shared nibble length).\\n                    require(\\n                        keyRemainder.length == sharedNibbleLength,\\n                        \\\"MerkleTrie: key remainder must be identical to path remainder\\\"\\n                    );\\n\\n                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum\\n                    // state trie. Empty values are not allowed in the state trie, so we can safely\\n                    // say that if the value is empty, the key should not exist and the proof is\\n                    // invalid.\\n                    value_ = RLPReader.readBytes(currentNode.decoded[1]);\\n                    require(value_.length > 0, \\\"MerkleTrie: value length must be greater than zero (leaf)\\\");\\n\\n                    // Extra proof elements are not allowed.\\n                    require(i == proof.length - 1, \\\"MerkleTrie: value node must be last node in proof (leaf)\\\");\\n\\n                    return value_;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node\\n                    // in the proof and increment the key index by the length of the path remainder\\n                    // which is equal to the shared nibble length.\\n                    currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                    currentKeyIndex += sharedNibbleLength;\\n                } else {\\n                    revert(\\\"MerkleTrie: received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"MerkleTrie: received an unparseable node\\\");\\n            }\\n        }\\n\\n        revert(\\\"MerkleTrie: ran out of proof elements\\\");\\n    }\\n\\n    /// @notice Parses an array of proof elements into a new array that contains both the original\\n    ///         encoded element and the RLP-decoded element.\\n    /// @param _proof Array of proof elements to parse.\\n    /// @return proof_ Proof parsed into easily accessible structs.\\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) {\\n        uint256 length = _proof.length;\\n        proof_ = new TrieNode[](length);\\n        for (uint256 i = 0; i < length;) {\\n            proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Picks out the ID for a node. Node ID is referred to as the \\\"hash\\\" within the\\n    ///         specification, but nodes < 32 bytes are not actually hashed.\\n    /// @param _node Node to pull an ID for.\\n    /// @return id_ ID for the node, depending on the size of its contents.\\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory id_) {\\n        id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\\n    }\\n\\n    /// @notice Gets the path for a leaf or extension node.\\n    /// @param _node Node to get a path for.\\n    /// @return nibbles_ Node path, converted to an array of nibbles.\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory nibbles_) {\\n        nibbles_ = Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /// @notice Utility; determines the number of nibbles shared between two nibble arrays.\\n    /// @param _a First nibble array.\\n    /// @param _b Second nibble array.\\n    /// @return shared_ Number of shared nibbles.\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b) private pure returns (uint256 shared_) {\\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\\n        for (; shared_ < max && _a[shared_] == _b[shared_];) {\\n            unchecked {\\n                ++shared_;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf8ba770ee6666e73ae43184c700e9c704b2c4ace71f9e3c2227ddc11a8148b4c\",\"license\":\"MIT\"},\"contracts/libraries/trie/SecureMerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { MerkleTrie } from \\\"./MerkleTrie.sol\\\";\\n\\n/// @title SecureMerkleTrie\\n/// @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\\n///         keys. Ethereum's state trie hashes input keys before storing them.\\nlibrary SecureMerkleTrie {\\n    /// @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\\n    /// @param _key   Key of the node to search for, as a hex string.\\n    /// @param _value Value of the node to search for, as a hex string.\\n    /// @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n    ///               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n    ///               nodes that make a path down to the target node.\\n    /// @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n    ///               correctly constructed.\\n    /// @return valid_ Whether or not the proof is valid.\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        valid_ = MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /// @notice Retrieves the value associated with a given key.\\n    /// @param _key   Key to search for, as hex bytes.\\n    /// @param _proof Merkle trie inclusion proof for the key.\\n    /// @param _root  Known root of the Merkle trie.\\n    /// @return value_ Value of the key if it exists.\\n    function get(bytes memory _key, bytes[] memory _proof, bytes32 _root) internal pure returns (bytes memory value_) {\\n        bytes memory key = _getSecureKey(_key);\\n        value_ = MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /// @notice Computes the hashed version of the input key.\\n    /// @param _key Key to hash.\\n    /// @return hash_ Hashed version of the key.\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory hash_) {\\n        hash_ = abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\",\"keccak256\":\"0xeaff8315cfd21197bc6bc859c2decf5d4f4838c9c357c502cdf2b1eac863d288\",\"license\":\"MIT\"},\"contracts/oasys/L1Build/Build_L1StandardBridge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Semver } from \\\"../../universal/Semver.sol\\\";\\nimport { ProxyAdmin } from \\\"../../universal/ProxyAdmin.sol\\\";\\nimport { L1StandardBridge } from \\\"../../L1/L1StandardBridge.sol\\\";\\nimport { L1CrossDomainMessenger } from \\\"../../L1/L1CrossDomainMessenger.sol\\\";\\n\\n/// @notice Hold the deployment bytecode\\n///         Separate from build contract to avoid bytecode size limitations\\ncontract Build_L1StandardBridge is Semver {\\n    constructor() Semver(1, 0, 0) {}\\n\\n    /// @notice The create2 salt used for deployment of the contract implementations.\\n    function deployBytecode() public pure returns (bytes memory) {\\n        return type(L1StandardBridge).creationCode;\\n    }\\n}\\n\",\"keccak256\":\"0xddec6f346bb241cdbb40299a02e37d52976aa638e132d7db2fc192f9a39b2892\",\"license\":\"MIT\"},\"contracts/universal/CrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { Hashing } from \\\"../libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"../libraries/Encoding.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\n\\n/// @custom:legacy\\n/// @title CrossDomainMessengerLegacySpacer0\\n/// @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n///         libAddressManager variable used to exist. Must be the first contract in the inheritance\\n///         tree of the CrossDomainMessenger.\\ncontract CrossDomainMessengerLegacySpacer0 {\\n    /// @custom:legacy\\n    /// @custom:spacer libAddressManager\\n    /// @notice Spacer for backwards compatibility.\\n    address private spacer_0_0_20;\\n}\\n\\n/// @custom:legacy\\n/// @title CrossDomainMessengerLegacySpacer1\\n/// @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n///         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\\n///         the third contract in the inheritance tree of the CrossDomainMessenger.\\ncontract CrossDomainMessengerLegacySpacer1 {\\n    /// @custom:legacy\\n    /// @custom:spacer ContextUpgradable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         ContextUpgradable.\\n    uint256[50] private spacer_1_0_1600;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer OwnableUpgradeable's _owner\\n    /// @notice Spacer for backwards compatibility.\\n    ///         Come from OpenZeppelin OwnableUpgradeable.\\n    address private spacer_51_0_20;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer OwnableUpgradeable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         OwnableUpgradeable.\\n    uint256[49] private spacer_52_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer PausableUpgradable's _paused\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         PausableUpgradable.\\n    bool private spacer_101_0_1;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer PausableUpgradable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         PausableUpgradable.\\n    uint256[49] private spacer_102_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\\n    /// @notice Spacer for backwards compatibility.\\n    uint256 private spacer_151_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer ReentrancyGuardUpgradeable's __gap\\n    /// @notice Spacer for backwards compatibility.\\n    uint256[49] private spacer_152_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer blockedMessages\\n    /// @notice Spacer for backwards compatibility.\\n    mapping(bytes32 => bool) private spacer_201_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer relayedMessages\\n    /// @notice Spacer for backwards compatibility.\\n    mapping(bytes32 => bool) private spacer_202_0_32;\\n}\\n\\n/// @custom:upgradeable\\n/// @title CrossDomainMessenger\\n/// @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\\n///         cross-chain messenger contracts. It's designed to be a universal interface that only\\n///         needs to be extended slightly to provide low-level message passing functionality on each\\n///         chain it's deployed on. Currently only designed for message passing between two paired\\n///         chains and does not support one-to-many interactions.\\n///         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\\nabstract contract CrossDomainMessenger is\\n    CrossDomainMessengerLegacySpacer0,\\n    Initializable,\\n    CrossDomainMessengerLegacySpacer1\\n{\\n    /// @notice Current message version identifier.\\n    uint16 public constant MESSAGE_VERSION = 1;\\n\\n    /// @notice Constant overhead added to the base gas for a message.\\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\\n\\n    /// @notice Numerator for dynamic overhead added to the base gas for a message.\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\\n\\n    /// @notice Denominator for dynamic overhead added to the base gas for a message.\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\\n\\n    /// @notice Extra gas added to base gas for each byte of calldata in a message.\\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\\n\\n    /// @notice Gas reserved for performing the external call in `relayMessage`.\\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\\n\\n    /// @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\\n\\n    /// @notice Gas reserved for the execution between the `hasMinGas` check and the external\\n    ///         call in `relayMessage`.\\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\\n\\n    /// @notice Address of the paired CrossDomainMessenger contract on the other chain.\\n    address public immutable OTHER_MESSENGER;\\n\\n    /// @notice Mapping of message hashes to boolean receipt values. Note that a message will only\\n    ///         be present in this mapping if it has successfully been relayed on this chain, and\\n    ///         can therefore not be relayed again.\\n    mapping(bytes32 => bool) public successfulMessages;\\n\\n    /// @notice Address of the sender of the currently executing message on the other chain. If the\\n    ///         value of this variable is the default value (0x00000000...dead) then no message is\\n    ///         currently being executed. Use the xDomainMessageSender getter which will throw an\\n    ///         error if this is the case.\\n    address internal xDomainMsgSender;\\n\\n    /// @notice Nonce for the next message to be sent, without the message version applied. Use the\\n    ///         messageNonce getter which will insert the message version into the nonce to give you\\n    ///         the actual nonce to be used for the message.\\n    uint240 internal msgNonce;\\n\\n    /// @notice Mapping of message hashes to a boolean if and only if the message has failed to be\\n    ///         executed at least once. A message will not be present in this mapping if it\\n    ///         successfully executed on the first attempt.\\n    mapping(bytes32 => bool) public failedMessages;\\n\\n    /// @notice Reserve extra slots in the storage layout for future upgrades.\\n    ///         A gap size of 41 was chosen here, so that the first slot used in a child contract\\n    ///         would be a multiple of 50.\\n    uint256[42] private __gap;\\n\\n    /// @notice Emitted whenever a message is sent to the other chain.\\n    /// @param target       Address of the recipient of the message.\\n    /// @param sender       Address of the sender of the message.\\n    /// @param message      Message to trigger the recipient address with.\\n    /// @param messageNonce Unique nonce attached to the message.\\n    /// @param gasLimit     Minimum gas limit that the message can be executed with.\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n\\n    /// @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\\n    ///         SentMessage event without breaking the ABI of this contract, this is good enough.\\n    /// @param sender Address of the sender of the message.\\n    /// @param value  ETH value sent along with the message to the recipient.\\n    event SentMessageExtension1(address indexed sender, uint256 value);\\n\\n    /// @notice Emitted whenever a message is successfully relayed on this chain.\\n    /// @param msgHash Hash of the message that was relayed.\\n    event RelayedMessage(bytes32 indexed msgHash);\\n\\n    /// @notice Emitted whenever a message fails to be relayed on this chain.\\n    /// @param msgHash Hash of the message that failed to be relayed.\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /// @param _otherMessenger Address of the messenger on the paired chain.\\n    constructor(address _otherMessenger) {\\n        OTHER_MESSENGER = _otherMessenger;\\n    }\\n\\n    /// @notice Sends a message to some target address on the other chain. Note that if the call\\n    ///         always reverts, then the message will be unrelayable, and any ETH sent will be\\n    ///         permanently locked. The same will occur if the target on the other chain is\\n    ///         considered unsafe (see the _isUnsafeTarget() function).\\n    /// @param _target      Target contract or wallet address.\\n    /// @param _message     Message to trigger the target address with.\\n    /// @param _minGasLimit Minimum gas limit that the message can be executed with.\\n    function sendMessage(address _target, bytes calldata _message, uint32 _minGasLimit) external payable {\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage(\\n            OTHER_MESSENGER,\\n            baseGas(_message, _minGasLimit),\\n            msg.value,\\n            abi.encodeWithSelector(\\n                this.relayMessage.selector, messageNonce(), msg.sender, _target, msg.value, _minGasLimit, _message\\n            )\\n        );\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /// @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n    ///         be executed via cross-chain call from the other messenger OR if the message was\\n    ///         already received once and is currently being replayed.\\n    /// @param _nonce       Nonce of the message being relayed.\\n    /// @param _sender      Address of the user who sent the message.\\n    /// @param _target      Address that the message is targeted at.\\n    /// @param _value       ETH value to send with the message.\\n    /// @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n    /// @param _message     Message to send to the target.\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _minGasLimit,\\n        bytes calldata _message\\n    )\\n        external\\n        payable\\n    {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        require(version < 2, \\\"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\\\");\\n\\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\\n        // to check that the legacy version of the message has not already been relayed.\\n        if (version == 0) {\\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\\n            require(successfulMessages[oldHash] == false, \\\"CrossDomainMessenger: legacy withdrawal already relayed\\\");\\n        }\\n\\n        // We use the v1 message hash as the unique identifier for the message because it commits\\n        // to the value and minimum gas limit of the message.\\n        bytes32 versionedHash =\\n            Hashing.hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _minGasLimit, _message);\\n\\n        if (_isOtherMessenger()) {\\n            // These properties should always hold when the message is first submitted (as\\n            // opposed to being replayed).\\n            assert(msg.value == _value);\\n            assert(!failedMessages[versionedHash]);\\n        } else {\\n            require(msg.value == 0, \\\"CrossDomainMessenger: value must be zero unless message is from a system address\\\");\\n\\n            require(failedMessages[versionedHash], \\\"CrossDomainMessenger: message cannot be replayed\\\");\\n        }\\n\\n        require(\\n            _isUnsafeTarget(_target) == false, \\\"CrossDomainMessenger: cannot send message to blocked system address\\\"\\n        );\\n\\n        require(successfulMessages[versionedHash] == false, \\\"CrossDomainMessenger: message has already been relayed\\\");\\n\\n        // If there is not enough gas left to perform the external call and finish the execution,\\n        // return early and assign the message to the failedMessages mapping.\\n        // We are asserting that we have enough gas to:\\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\\n        //\\n        // If `xDomainMsgSender` is not the default L2 sender, this function\\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\\n        if (\\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER)\\n                || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\\n        ) {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n\\n            return;\\n        }\\n\\n        xDomainMsgSender = _sender;\\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n\\n        if (success) {\\n            successfulMessages[versionedHash] = true;\\n            emit RelayedMessage(versionedHash);\\n        } else {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n        }\\n    }\\n\\n    /// @notice Retrieves the address of the contract or wallet that initiated the currently\\n    ///         executing message on the other chain. Will throw an error if there is no message\\n    ///         currently being executed. Allows the recipient of a call to see who triggered it.\\n    /// @return Address of the sender of the currently executing message on the other chain.\\n    function xDomainMessageSender() external view returns (address) {\\n        require(\\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER, \\\"CrossDomainMessenger: xDomainMessageSender is not set\\\"\\n        );\\n\\n        return xDomainMsgSender;\\n    }\\n\\n    /// @notice Retrieves the next message nonce. Message version will be added to the upper two\\n    ///         bytes of the message nonce. Message version allows us to treat messages as having\\n    ///         different structures.\\n    /// @return Nonce of the next message to be sent, with added message version.\\n    function messageNonce() public view returns (uint256) {\\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\\n    }\\n\\n    /// @notice Computes the amount of gas required to guarantee that a given message will be\\n    ///         received on the other chain without running out of gas. Guaranteeing that a message\\n    ///         will not run out of gas is important because this ensures that a message can always\\n    ///         be replayed on the other chain if it fails to execute completely.\\n    /// @param _message     Message to compute the amount of required gas for.\\n    /// @param _minGasLimit Minimum desired gas limit when message goes to target.\\n    /// @return Amount of gas required to guarantee message receipt.\\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\\n        return\\n        // Constant overhead\\n        RELAY_CONSTANT_OVERHEAD\\n        // Calldata overhead\\n        + (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD)\\n        // Dynamic overhead (EIP-150)\\n        + ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) / MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR)\\n        // Gas reserved for the worst-case cost of 3/5 of the `CALL` opcode's dynamic gas\\n        // factors. (Conservative)\\n        + RELAY_CALL_OVERHEAD\\n        // Relay reserved gas (to ensure execution of `relayMessage` completes after the\\n        // subcontext finishes executing) (Conservative)\\n        + RELAY_RESERVED_GAS\\n        // Gas reserved for the execution between the `hasMinGas` check and the `CALL`\\n        // opcode. (Conservative)\\n        + RELAY_GAS_CHECK_BUFFER;\\n    }\\n\\n    /// @notice Initializer.\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __CrossDomainMessenger_init() internal onlyInitializing {\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n    }\\n\\n    /// @notice Sends a low-level message to the other messenger. Needs to be implemented by child\\n    ///         contracts because the logic for this depends on the network where the messenger is\\n    ///         being deployed.\\n    /// @param _to       Recipient of the message on the other chain.\\n    /// @param _gasLimit Minimum gas limit the message can be executed with.\\n    /// @param _value    Amount of ETH to send with the message.\\n    /// @param _data     Message data.\\n    function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal virtual;\\n\\n    /// @notice Checks whether the message is coming from the other messenger. Implemented by child\\n    ///         contracts because the logic for this depends on the network where the messenger is\\n    ///         being deployed.\\n    /// @return Whether the message is coming from the other messenger.\\n    function _isOtherMessenger() internal view virtual returns (bool);\\n\\n    /// @notice Checks whether a given call target is a system address that could cause the\\n    ///         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\\n    ///         addresses. This is ONLY used to prevent the execution of messages to specific\\n    ///         system addresses that could cause security issues, e.g., having the\\n    ///         CrossDomainMessenger send messages to itself.\\n    /// @param _target Address of the contract to check.\\n    /// @return Whether or not the address is an unsafe system address.\\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0x4302ae78bcafde2737d4048bbf8fdb3dd4cd7254c015b91dfa14fdaafd412f4a\",\"license\":\"MIT\"},\"contracts/universal/IOptimismMintableERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title IOptimismMintableERC20\\n/// @notice This interface is available on the OptimismMintableERC20 contract.\\n///         We declare it as a separate interface so that it can be used in\\n///         custom implementations of OptimismMintableERC20.\\ninterface IOptimismMintableERC20 is IERC165 {\\n    function remoteToken() external view returns (address);\\n\\n    function bridge() external returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\\n/// @custom:legacy\\n/// @title ILegacyMintableERC20\\n/// @notice This interface was available on the legacy L2StandardERC20 contract.\\n///         It remains available on the OptimismMintableERC20 contract for\\n///         backwards compatibility.\\ninterface ILegacyMintableERC20 is IERC165 {\\n    function l1Token() external view returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x6f8133b39efcbcbd5088f195dfacf1bedc3146508429c3865443909af735a04c\",\"license\":\"MIT\"},\"contracts/universal/ISemver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISemver\\n/// @notice ISemver is a simple contract for ensuring that contracts are\\n///         versioned using semantic versioning.\\ninterface ISemver {\\n    /// @notice Getter for the semantic version of the contract. This is not\\n    ///         meant to be used onchain but instead meant to be used by offchain\\n    ///         tooling.\\n    /// @return Semver contract version as a string.\\n    function version() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xba34562a8026f59886d2e07d1d58d90b9691d00e0788c6263cef6c22740cab44\",\"license\":\"MIT\"},\"contracts/universal/OptimismMintableERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport { ILegacyMintableERC20, IOptimismMintableERC20 } from \\\"./IOptimismMintableERC20.sol\\\";\\nimport { Semver } from \\\"../universal/Semver.sol\\\";\\n\\n/// @title OptimismMintableERC20\\n/// @notice OptimismMintableERC20 is a standard extension of the base ERC20 token contract designed\\n///         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\\n///         use an OptimismMintablERC20 as the L2 representation of an L1 token, or vice-versa.\\n///         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\\n///         meant for use on L2.\\ncontract OptimismMintableERC20 is IOptimismMintableERC20, ILegacyMintableERC20, ERC20, Semver {\\n    /// @notice Address of the corresponding version of this token on the remote chain.\\n    address public immutable REMOTE_TOKEN;\\n\\n    /// @notice Address of the StandardBridge on this network.\\n    address public immutable BRIDGE;\\n\\n    /// @notice Decimals of the token\\n    uint8 private immutable DECIMALS;\\n\\n    /// @notice Emitted whenever tokens are minted for an account.\\n    /// @param account Address of the account tokens are being minted for.\\n    /// @param amount  Amount of tokens minted.\\n    event Mint(address indexed account, uint256 amount);\\n\\n    /// @notice Emitted whenever tokens are burned from an account.\\n    /// @param account Address of the account tokens are being burned from.\\n    /// @param amount  Amount of tokens burned.\\n    event Burn(address indexed account, uint256 amount);\\n\\n    /// @notice A modifier that only allows the bridge to call\\n    modifier onlyBridge() {\\n        require(msg.sender == BRIDGE, \\\"OptimismMintableERC20: only bridge can mint and burn\\\");\\n        _;\\n    }\\n\\n    /// @custom:semver 1.2.0\\n    /// @param _bridge      Address of the L2 standard bridge.\\n    /// @param _remoteToken Address of the corresponding L1 token.\\n    /// @param _name        ERC20 name.\\n    /// @param _symbol      ERC20 symbol.\\n    constructor(\\n        address _bridge,\\n        address _remoteToken,\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    )\\n        ERC20(_name, _symbol)\\n        Semver(1, 2, 0)\\n    {\\n        REMOTE_TOKEN = _remoteToken;\\n        BRIDGE = _bridge;\\n        DECIMALS = _decimals;\\n    }\\n\\n    /// @notice Allows the StandardBridge on this network to mint tokens.\\n    /// @param _to     Address to mint tokens to.\\n    /// @param _amount Amount of tokens to mint.\\n    function mint(\\n        address _to,\\n        uint256 _amount\\n    )\\n        external\\n        virtual\\n        override(IOptimismMintableERC20, ILegacyMintableERC20)\\n        onlyBridge\\n    {\\n        _mint(_to, _amount);\\n        emit Mint(_to, _amount);\\n    }\\n\\n    /// @notice Allows the StandardBridge on this network to burn tokens.\\n    /// @param _from   Address to burn tokens from.\\n    /// @param _amount Amount of tokens to burn.\\n    function burn(\\n        address _from,\\n        uint256 _amount\\n    )\\n        external\\n        virtual\\n        override(IOptimismMintableERC20, ILegacyMintableERC20)\\n        onlyBridge\\n    {\\n        _burn(_from, _amount);\\n        emit Burn(_from, _amount);\\n    }\\n\\n    /// @notice ERC165 interface check function.\\n    /// @param _interfaceId Interface ID to check.\\n    /// @return Whether or not the interface is supported by this contract.\\n    function supportsInterface(bytes4 _interfaceId) external pure virtual returns (bool) {\\n        bytes4 iface1 = type(IERC165).interfaceId;\\n        // Interface corresponding to the legacy L2StandardERC20.\\n        bytes4 iface2 = type(ILegacyMintableERC20).interfaceId;\\n        // Interface corresponding to the updated OptimismMintableERC20 (this contract).\\n        bytes4 iface3 = type(IOptimismMintableERC20).interfaceId;\\n        return _interfaceId == iface1 || _interfaceId == iface2 || _interfaceId == iface3;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Legacy getter for the remote token. Use REMOTE_TOKEN going forward.\\n    function l1Token() public view returns (address) {\\n        return REMOTE_TOKEN;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Legacy getter for the bridge. Use BRIDGE going forward.\\n    function l2Bridge() public view returns (address) {\\n        return BRIDGE;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Legacy getter for REMOTE_TOKEN.\\n    function remoteToken() public view returns (address) {\\n        return REMOTE_TOKEN;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Legacy getter for BRIDGE.\\n    function bridge() public view returns (address) {\\n        return BRIDGE;\\n    }\\n\\n    /// @dev Returns the number of decimals used to get its user representation.\\n    /// For example, if `decimals` equals `2`, a balance of `505` tokens should\\n    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n    /// NOTE: This information is only used for _display_ purposes: it in\\n    /// no way affects any of the arithmetic of the contract, including\\n    /// {IERC20-balanceOf} and {IERC20-transfer}.\\n    function decimals() public view override returns (uint8) {\\n        return DECIMALS;\\n    }\\n}\\n\",\"keccak256\":\"0x39af021e492020fbeb5401371010d4a2fb69debe9596dbbead7bcd7fae248b0b\",\"license\":\"MIT\"},\"contracts/universal/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\n\\n/// @title Proxy\\n/// @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\\n///         if the caller is address(0), meaning that the call originated from an off-chain\\n///         simulation.\\ncontract Proxy {\\n    /// @notice An event that is emitted each time the implementation is changed. This event is part\\n    ///         of the EIP-1967 specification.\\n    /// @param implementation The address of the implementation contract\\n    event Upgraded(address indexed implementation);\\n\\n    /// @notice An event that is emitted each time the owner is upgraded. This event is part of the\\n    ///         EIP-1967 specification.\\n    /// @param previousAdmin The previous owner of the contract\\n    /// @param newAdmin      The new owner of the contract\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /// @notice A modifier that reverts if not called by the owner or by address(0) to allow\\n    ///         eth_call to interact with this proxy without needing to use low-level storage\\n    ///         inspection. We assume that nobody is able to trigger calls from address(0) during\\n    ///         normal EVM execution.\\n    modifier proxyCallIfNotAdmin() {\\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /// @notice Sets the initial admin during contract deployment. Admin address is stored at the\\n    ///         EIP-1967 admin storage slot so that accidental storage collision with the\\n    ///         implementation is not possible.\\n    /// @param _admin Address of the initial contract admin. Admin as the ability to access the\\n    ///               transparent proxy interface.\\n    constructor(address _admin) {\\n        _changeAdmin(_admin);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /// @notice Set the implementation contract address. The code at the given address will execute\\n    ///         when this contract is called.\\n    /// @param _implementation Address of the implementation contract.\\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /// @notice Set the implementation and call a function in a single transaction. Useful to ensure\\n    ///         atomic execution of initialization-based upgrades.\\n    /// @param _implementation Address of the implementation contract.\\n    /// @param _data           Calldata to delegatecall the new implementation with.\\n    function upgradeToAndCall(\\n        address _implementation,\\n        bytes calldata _data\\n    )\\n        public\\n        payable\\n        virtual\\n        proxyCallIfNotAdmin\\n        returns (bytes memory)\\n    {\\n        _setImplementation(_implementation);\\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\\n        require(success, \\\"Proxy: delegatecall to new implementation contract failed\\\");\\n        return returndata;\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract. Only callable by the owner.\\n    /// @param _admin New owner of the proxy contract.\\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\\n        _changeAdmin(_admin);\\n    }\\n\\n    /// @notice Gets the owner of the proxy contract.\\n    /// @return Owner address.\\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    //// @notice Queries the implementation address.\\n    /// @return Implementation address.\\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /// @notice Sets the implementation address.\\n    /// @param _implementation New implementation address.\\n    function _setImplementation(address _implementation) internal {\\n        bytes32 proxyImplementation = Constants.PROXY_IMPLEMENTATION_ADDRESS;\\n        assembly {\\n            sstore(proxyImplementation, _implementation)\\n        }\\n        emit Upgraded(_implementation);\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract.\\n    /// @param _admin New owner of the proxy contract.\\n    function _changeAdmin(address _admin) internal {\\n        address previous = _getAdmin();\\n        bytes32 proxyOwner = Constants.PROXY_OWNER_ADDRESS;\\n        assembly {\\n            sstore(proxyOwner, _admin)\\n        }\\n        emit AdminChanged(previous, _admin);\\n    }\\n\\n    /// @notice Performs the proxy call via a delegatecall.\\n    function _doProxyCall() internal {\\n        address impl = _getImplementation();\\n        require(impl != address(0), \\\"Proxy: implementation not initialized\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) { revert(0x0, returndatasize()) }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /// @notice Queries the implementation address.\\n    /// @return Implementation address.\\n    function _getImplementation() internal view returns (address) {\\n        address impl;\\n        bytes32 proxyImplementation = Constants.PROXY_IMPLEMENTATION_ADDRESS;\\n        assembly {\\n            impl := sload(proxyImplementation)\\n        }\\n        return impl;\\n    }\\n\\n    /// @notice Queries the owner of the proxy contract.\\n    /// @return Owner address.\\n    function _getAdmin() internal view returns (address) {\\n        address owner;\\n        bytes32 proxyOwner = Constants.PROXY_OWNER_ADDRESS;\\n        assembly {\\n            owner := sload(proxyOwner)\\n        }\\n        return owner;\\n    }\\n}\\n\",\"keccak256\":\"0xc56de5e39cd44eaeb93f0f8705dd07f4a89f66d5c186522532cf899a104cdbca\",\"license\":\"MIT\"},\"contracts/universal/ProxyAdmin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { Proxy } from \\\"./Proxy.sol\\\";\\nimport { AddressManager } from \\\"../legacy/AddressManager.sol\\\";\\nimport { L1ChugSplashProxy } from \\\"../legacy/L1ChugSplashProxy.sol\\\";\\nimport { Constants } from \\\"../libraries/Constants.sol\\\";\\n\\n/// @title IStaticERC1967Proxy\\n/// @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\\ninterface IStaticERC1967Proxy {\\n    function implementation() external view returns (address);\\n\\n    function admin() external view returns (address);\\n}\\n\\n/// @title IStaticL1ChugSplashProxy\\n/// @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\\ninterface IStaticL1ChugSplashProxy {\\n    function getImplementation() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n}\\n\\n/// @title ProxyAdmin\\n/// @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\\n///         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\\n///         with the various types of proxies that have been deployed by Optimism in the past.\\ncontract ProxyAdmin is Ownable {\\n    /// @notice The proxy types that the ProxyAdmin can manage.\\n    /// @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\\n    /// @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\\n    /// @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\\n    enum ProxyType {\\n        ERC1967,\\n        CHUGSPLASH,\\n        RESOLVED\\n    }\\n\\n    /// @notice A mapping of proxy types, used for backwards compatibility.\\n    mapping(address => ProxyType) public proxyType;\\n\\n    /// @notice A reverse mapping of addresses to names held in the AddressManager. This must be\\n    ///         manually kept up to date with changes in the AddressManager for this contract\\n    ///         to be able to work as an admin for the ResolvedDelegateProxy type.\\n    mapping(address => string) public implementationName;\\n\\n    /// @notice The address of the address manager, this is required to manage the\\n    ///         ResolvedDelegateProxy type.\\n    AddressManager public addressManager;\\n\\n    /// @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\\n    bool internal upgrading;\\n\\n    /// @param _owner Address of the initial owner of this contract.\\n    constructor(address _owner) Ownable() {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /// @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\\n    ///         proxy types.\\n    /// @param _address Address of the proxy.\\n    /// @param _type    Type of the proxy.\\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\\n        proxyType[_address] = _type;\\n    }\\n\\n    /// @notice Sets the implementation name for a given address. Only required for\\n    ///         ResolvedDelegateProxy type proxies that have an implementation name.\\n    /// @param _address Address of the ResolvedDelegateProxy.\\n    /// @param _name    Name of the implementation for the proxy.\\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\\n        implementationName[_address] = _name;\\n    }\\n\\n    /// @notice Set the address of the AddressManager. This is required to manage legacy\\n    ///         ResolvedDelegateProxy type proxy contracts.\\n    /// @param _address Address of the AddressManager.\\n    function setAddressManager(AddressManager _address) external onlyOwner {\\n        addressManager = _address;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Set an address in the address manager. Since only the owner of the AddressManager\\n    ///         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\\n    ///         gives the owner of the ProxyAdmin the ability to modify addresses directly.\\n    /// @param _name    Name to set within the AddressManager.\\n    /// @param _address Address to attach to the given name.\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        addressManager.setAddress(_name, _address);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Set the upgrading status for the Chugsplash proxy type.\\n    /// @param _upgrading Whether or not the system is upgrading.\\n    function setUpgrading(bool _upgrading) external onlyOwner {\\n        upgrading = _upgrading;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\\n    /// @return Whether or not there is an upgrade going on. May not actually tell you whether an\\n    ///         upgrade is going on, since we don't currently plan to use this variable for anything\\n    ///         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\\n    function isUpgrading() external view returns (bool) {\\n        return upgrading;\\n    }\\n\\n    /// @notice Returns the implementation of the given proxy address.\\n    /// @param _proxy Address of the proxy to get the implementation of.\\n    /// @return Address of the implementation of the proxy.\\n    function getProxyImplementation(address _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).implementation();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.getAddress(implementationName[_proxy]);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /// @notice Returns the admin of the given proxy address.\\n    /// @param _proxy Address of the proxy to get the admin of.\\n    /// @return Address of the admin of the proxy.\\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).admin();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.owner();\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /// @notice Updates the admin of the given proxy address.\\n    /// @param _proxy    Address of the proxy to update.\\n    /// @param _newAdmin Address of the new proxy admin.\\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).changeAdmin(_newAdmin);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            addressManager.transferOwnership(_newAdmin);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /// @notice Changes a proxy's implementation contract.\\n    /// @param _proxy          Address of the proxy to upgrade.\\n    /// @param _implementation Address of the new implementation address.\\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeTo(_implementation);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setStorage(\\n                Constants.PROXY_IMPLEMENTATION_ADDRESS, bytes32(uint256(uint160(_implementation)))\\n            );\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            string memory name = implementationName[_proxy];\\n            addressManager.setAddress(name, _implementation);\\n        } else {\\n            // It should not be possible to retrieve a ProxyType value which is not matched by\\n            // one of the previous conditions.\\n            assert(false);\\n        }\\n    }\\n\\n    /// @notice Changes a proxy's implementation contract and delegatecalls the new implementation\\n    ///         with some given data. Useful for atomic upgrade-and-initialize calls.\\n    /// @param _proxy          Address of the proxy to upgrade.\\n    /// @param _implementation Address of the new implementation address.\\n    /// @param _data           Data to trigger the new implementation with.\\n    function upgradeAndCall(\\n        address payable _proxy,\\n        address _implementation,\\n        bytes memory _data\\n    )\\n        external\\n        payable\\n        onlyOwner\\n    {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\\n        } else {\\n            // reverts if proxy type is unknown\\n            upgrade(_proxy, _implementation);\\n            (bool success,) = _proxy.call{ value: msg.value }(_data);\\n            require(success, \\\"ProxyAdmin: call to proxy after upgrade failed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc0212013525d6b5516a9b8b84e3cfd158bc52a6208cd4c8b806c8a2c959cc116\",\"license\":\"MIT\"},\"contracts/universal/Semver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/// @title Semver\\n/// @notice Semver is a simple contract for managing contract versions.\\ncontract Semver {\\n    /// @notice Contract version number (major).\\n    uint256 private immutable MAJOR_VERSION;\\n\\n    /// @notice Contract version number (minor).\\n    uint256 private immutable MINOR_VERSION;\\n\\n    /// @notice Contract version number (patch).\\n    uint256 private immutable PATCH_VERSION;\\n\\n    /// @param _major Version number (major).\\n    /// @param _minor Version number (minor).\\n    /// @param _patch Version number (patch).\\n    constructor(uint256 _major, uint256 _minor, uint256 _patch) {\\n        MAJOR_VERSION = _major;\\n        MINOR_VERSION = _minor;\\n        PATCH_VERSION = _patch;\\n    }\\n\\n    /// @notice Returns the full semver contract version.\\n    /// @return Semver contract version as a string.\\n    function version() public view returns (string memory) {\\n        return string(\\n            abi.encodePacked(\\n                Strings.toString(MAJOR_VERSION),\\n                \\\".\\\",\\n                Strings.toString(MINOR_VERSION),\\n                \\\".\\\",\\n                Strings.toString(PATCH_VERSION)\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x9de68ce536aee1aa616b4bf88d7ccc335460e6edd0e7170bdbf94c4fe3d41c60\",\"license\":\"MIT\"},\"contracts/universal/StandardBridge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { SafeCall } from \\\"../libraries/SafeCall.sol\\\";\\nimport { IOptimismMintableERC20, ILegacyMintableERC20 } from \\\"./IOptimismMintableERC20.sol\\\";\\nimport { CrossDomainMessenger } from \\\"./CrossDomainMessenger.sol\\\";\\nimport { OptimismMintableERC20 } from \\\"./OptimismMintableERC20.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n/// @custom:upgradeable\\n/// @title StandardBridge\\n/// @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\\n///         the core bridging logic, including escrowing tokens that are native to the local chain\\n///         and minting/burning tokens that are native to the remote chain.\\nabstract contract StandardBridge is Initializable {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice The L2 gas limit set when eth is depoisited using the receive() function.\\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\\n\\n    /// @notice Corresponding bridge on the other domain. This public getter is deprecated\\n    ///         and will be removed in the future. Please use `otherBridge` instead.\\n    /// @custom:legacy\\n    /// @custom:network-specific\\n    StandardBridge public immutable OTHER_BRIDGE;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer messenger\\n    /// @notice Spacer for backwards compatibility.\\n    address private spacer_0_2_20;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer l2TokenBridge\\n    /// @notice Spacer for backwards compatibility.\\n    address private spacer_1_0_20;\\n\\n    /// @notice Mapping that stores deposits for a given pair of local and remote tokens.\\n    mapping(address => mapping(address => uint256)) public deposits;\\n\\n    /// @notice Messenger contract on this domain. This public getter is deprecated\\n    ///         and will be removed in the future. Please use `messenger` instead.\\n    /// @custom:network-specific\\n    CrossDomainMessenger public messenger;\\n\\n    /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n    ///         A gap size of 46 was chosen here, so that the first slot used in a child contract\\n    ///         would be a multiple of 50.\\n    uint256[46] private __gap;\\n\\n    /// @notice Emitted when an ETH bridge is initiated to the other chain.\\n    /// @param from      Address of the sender.\\n    /// @param to        Address of the receiver.\\n    /// @param amount    Amount of ETH sent.\\n    /// @param extraData Extra data sent with the transaction.\\n    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @notice Emitted when an ETH bridge is finalized on this chain.\\n    /// @param from      Address of the sender.\\n    /// @param to        Address of the receiver.\\n    /// @param amount    Amount of ETH sent.\\n    /// @param extraData Extra data sent with the transaction.\\n    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @notice Emitted when an ERC20 bridge is initiated to the other chain.\\n    /// @param localToken  Address of the ERC20 on this chain.\\n    /// @param remoteToken Address of the ERC20 on the remote chain.\\n    /// @param from        Address of the sender.\\n    /// @param to          Address of the receiver.\\n    /// @param amount      Amount of the ERC20 sent.\\n    /// @param extraData   Extra data sent with the transaction.\\n    event ERC20BridgeInitiated(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @notice Emitted when an ERC20 bridge is finalized on this chain.\\n    /// @param localToken  Address of the ERC20 on this chain.\\n    /// @param remoteToken Address of the ERC20 on the remote chain.\\n    /// @param from        Address of the sender.\\n    /// @param to          Address of the receiver.\\n    /// @param amount      Amount of the ERC20 sent.\\n    /// @param extraData   Extra data sent with the transaction.\\n    event ERC20BridgeFinalized(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\\n    ///         calling code within their constructors, but also doesn't really matter since we're\\n    ///         just trying to prevent users accidentally depositing with smart contract wallets.\\n    modifier onlyEOA() {\\n        require(!Address.isContract(msg.sender), \\\"StandardBridge: function can only be called from an EOA\\\");\\n        _;\\n    }\\n\\n    /// @notice Ensures that the caller is a cross-chain message from the other bridge.\\n    modifier onlyOtherBridge() {\\n        require(\\n            msg.sender == address(messenger) && messenger.xDomainMessageSender() == address(OTHER_BRIDGE),\\n            \\\"StandardBridge: function can only be called from the other bridge\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @param _otherBridge Address of the other StandardBridge contract.\\n    constructor(StandardBridge _otherBridge) {\\n        OTHER_BRIDGE = _otherBridge;\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _messenger   Address of CrossDomainMessenger on this network.\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __StandardBridge_init(CrossDomainMessenger _messenger) internal onlyInitializing {\\n        messenger = _messenger;\\n    }\\n\\n    /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n    ///         Must be implemented by contracts that inherit.\\n    receive() external payable virtual;\\n\\n    /// @notice Getter for messenger contract.\\n    /// @custom:legacy\\n    /// @return Messenger contract on this domain.\\n    function MESSENGER() external view returns (CrossDomainMessenger) {\\n        return messenger;\\n    }\\n\\n    /// @notice Getter for the remote domain bridge contract.\\n    function otherBridge() external view returns (StandardBridge) {\\n        return OTHER_BRIDGE;\\n    }\\n\\n    /// @notice Sends ETH to the sender's address on the other chain.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\\n    ///         smart contract and the call fails, the ETH will be temporarily locked in the\\n    ///         StandardBridge on the other chain until the call is replayed. If the call cannot be\\n    ///         replayed with any amount of gas (call always reverts), then the ETH will be\\n    ///         permanently locked in the StandardBridge on the other chain. ETH will also\\n    ///         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\\n    ///         in that case.\\n    /// @param _to          Address of the receiver.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeETHTo(address _to, uint32 _minGasLimit, bytes calldata _extraData) public payable {\\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\\n    ///         ERC20 token on the other chain does not recognize the local token as the correct\\n    ///         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n    ///         this chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _amount      Amount of local tokens to deposit.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        public\\n        virtual\\n        onlyEOA\\n    {\\n        _initiateBridgeERC20(_localToken, _remoteToken, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\\n    ///         ERC20 token on the other chain does not recognize the local token as the correct\\n    ///         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n    ///         this chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of local tokens to deposit.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeERC20To(\\n        address _localToken,\\n        address _remoteToken,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        public\\n        virtual\\n    {\\n        _initiateBridgeERC20(_localToken, _remoteToken, msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\\n    ///         StandardBridge contract on the remote chain.\\n    /// @param _from      Address of the sender.\\n    /// @param _to        Address of the receiver.\\n    /// @param _amount    Amount of ETH being bridged.\\n    /// @param _extraData Extra data to be sent with the transaction. Note that the recipient will\\n    ///                   not be triggered with this data, but it will be emitted and can be used\\n    ///                   to identify the transaction.\\n    function finalizeBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        public\\n        payable\\n        onlyOtherBridge\\n    {\\n        require(msg.value == _amount, \\\"StandardBridge: amount sent does not match amount required\\\");\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(messenger), \\\"StandardBridge: cannot send to messenger\\\");\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n\\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\\\"\\\");\\n        require(success, \\\"StandardBridge: ETH transfer failed\\\");\\n    }\\n\\n    /// @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\\n    ///         StandardBridge contract on the remote chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of the ERC20 being bridged.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function finalizeBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        public\\n        onlyOtherBridge\\n    {\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\\n        } else {\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\\n            IERC20(_localToken).safeTransfer(_to, _amount);\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Initiates a bridge of ETH through the CrossDomainMessenger.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of ETH being bridged.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function _initiateBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        require(msg.value == _amount, \\\"StandardBridge: bridging ETH must include sufficient ETH value\\\");\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n\\n        messenger.sendMessage{ value: _amount }(\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of local tokens to deposit.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function _initiateBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\\n        } else {\\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n\\n        messenger.sendMessage(\\n            address(OTHER_BRIDGE),\\n            abi.encodeWithSelector(\\n                this.finalizeBridgeERC20.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _remoteToken,\\n                _localToken,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit\\n        );\\n    }\\n\\n    /// @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\\n    ///         Just the way we like it.\\n    /// @param _token Address of the token to check.\\n    /// @return True if the token is an OptimismMintableERC20.\\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\\n        return ERC165Checker.supportsInterface(_token, type(ILegacyMintableERC20).interfaceId)\\n            || ERC165Checker.supportsInterface(_token, type(IOptimismMintableERC20).interfaceId);\\n    }\\n\\n    /// @notice Checks if the \\\"other token\\\" is the correct pair token for the OptimismMintableERC20.\\n    ///         Calls can be saved in the future by combining this logic with\\n    ///         `_isOptimismMintableERC20`.\\n    /// @param _mintableToken OptimismMintableERC20 to check against.\\n    /// @param _otherToken    Pair token to check.\\n    /// @return True if the other token is the correct pair token for the OptimismMintableERC20.\\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken) internal view returns (bool) {\\n        if (ERC165Checker.supportsInterface(_mintableToken, type(ILegacyMintableERC20).interfaceId)) {\\n            return _otherToken == ILegacyMintableERC20(_mintableToken).l1Token();\\n        } else {\\n            return _otherToken == IOptimismMintableERC20(_mintableToken).remoteToken();\\n        }\\n    }\\n\\n    /// @notice Emits the ETHBridgeInitiated event and if necessary the appropriate legacy event\\n    ///         when an ETH bridge is finalized on this chain.\\n    /// @param _from      Address of the sender.\\n    /// @param _to        Address of the receiver.\\n    /// @param _amount    Amount of ETH sent.\\n    /// @param _extraData Extra data sent with the transaction.\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Emits the ETHBridgeFinalized and if necessary the appropriate legacy event when an\\n    ///         ETH bridge is finalized on this chain.\\n    /// @param _from      Address of the sender.\\n    /// @param _to        Address of the receiver.\\n    /// @param _amount    Amount of ETH sent.\\n    /// @param _extraData Extra data sent with the transaction.\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Emits the ERC20BridgeInitiated event and if necessary the appropriate legacy\\n    ///         event when an ERC20 bridge is initiated to the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the ERC20 on the remote chain.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of the ERC20 sent.\\n    /// @param _extraData   Extra data sent with the transaction.\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Emits the ERC20BridgeFinalized event and if necessary the appropriate legacy\\n    ///         event when an ERC20 bridge is initiated to the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the ERC20 on the remote chain.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of the ERC20 sent.\\n    /// @param _extraData   Extra data sent with the transaction.\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n}\\n\",\"keccak256\":\"0xd40e4671833946d92723217c4f3d6259f8cc705a5ed25e5529754046d575a411\",\"license\":\"MIT\"},\"contracts/vendor/AddressAliasHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ecb83b4ec80fbe49c22f4f95d90482de64660ef5d422a19f4d4b04df31c1237\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60e060405234801561001057600080fd5b5060016080819052600060a081905260c08190528061286d6100478239600060e40152600060bb015260006092015261286d6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806331d191661461003b57806354fd4d5014610059575b600080fd5b610043610061565b60405161005091906102d4565b60405180910390f35b61004361008b565b6060604051806020016100739061026b565b601f1982820381018352601f90910116604052919050565b60606100b67f000000000000000000000000000000000000000000000000000000000000000061012e565b6100df7f000000000000000000000000000000000000000000000000000000000000000061012e565b6101087f000000000000000000000000000000000000000000000000000000000000000061012e565b60405160200161011a939291906102ee565b604051602081830303815290604052905090565b60608160000361017157505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b8160005b811561019b57806101858161037a565b91506101949050600a836103a9565b9150610175565b60008167ffffffffffffffff8111156101b6576101b66103bd565b6040519080825280601f01601f1916602001820160405280156101e0576020820181803683370190505b5090505b8415610263576101f56001836103d3565b9150610202600a866103ea565b61020d9060306103fe565b60f81b81838151811061022257610222610416565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535061025c600a866103a9565b94506101e4565b949350505050565b61240b8061042d83390190565b60005b8381101561029357818101518382015260200161027b565b838111156102a2576000848401525b50505050565b600081518084526102c0816020860160208601610278565b601f01601f19169290920160200192915050565b6020815260006102e760208301846102a8565b9392505050565b60008451610300818460208901610278565b80830190507f2e00000000000000000000000000000000000000000000000000000000000000808252855161033c816001850160208a01610278565b60019201918201528351610357816002840160208801610278565b0160020195945050505050565b634e487b7160e01b600052601160045260246000fd5b60006001820161038c5761038c610364565b5060010190565b634e487b7160e01b600052601260045260246000fd5b6000826103b8576103b8610393565b500490565b634e487b7160e01b600052604160045260246000fd5b6000828210156103e5576103e5610364565b500390565b6000826103f9576103f9610393565b500690565b6000821982111561041157610411610364565b500190565b634e487b7160e01b600052603260045260246000fdfe60a06040523480156200001157600080fd5b507342000000000000000000000000000000000000106080526200003660006200003c565b62000144565b60008055600262000051565b60405180910390fd5b6000805461ffff191660ff8316176101001790556200007082620000b5565b6000805461ff001916905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b600054610100900460ff16620001225760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b606482015260840162000048565b600380546001600160a01b0319166001600160a01b0392909216919091179055565b6080516122886200018360003960008181610345015281816103fc015281816104fc015281816108ca01528181611052015261154d01526122886000f3fe6080604052600436106101635760003560e01c806387087623116100c0578063a9f9e67511610074578063c4d66de811610059578063c4d66de814610484578063c89701a2146103ed578063e11013dd146104a457600080fd5b8063a9f9e67514610451578063b1a1a8821461047157600080fd5b806391c49bf8116100a557806391c49bf8146103ed578063927ede2d146104205780639a2ac6d51461043e57600080fd5b806387087623146103875780638f601f66146103a757600080fd5b8063540abf731161011757806358a997f6116100fc57806358a997f6146103135780637f46ddb214610333578063838b25201461036757600080fd5b8063540abf731461029d57806354fd4d50146102bd57600080fd5b80631532ec34116101485780631532ec341461023a5780631635f5fd1461024d5780633cb747bf1461026057600080fd5b80630166a07a1461020757806309fc88431461022757600080fd5b3661020257333b156101e25760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084015b60405180910390fd5b610200333362030d40604051806020016040528060008152506104b7565b005b600080fd5b34801561021357600080fd5b50610200610222366004611cf8565b6104ca565b610200610235366004611da9565b6107c7565b610200610248366004611dfc565b610884565b61020061025b366004611dfc565b610898565b34801561026c57600080fd5b50600354610280906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156102a957600080fd5b506102006102b8366004611e6f565b610c16565b3480156102c957600080fd5b506103066040518060400160405280600581526020017f312e332e3000000000000000000000000000000000000000000000000000000081525081565b6040516102949190611f3e565b34801561031f57600080fd5b5061020061032e366004611f51565b610c5b565b34801561033f57600080fd5b506102807f000000000000000000000000000000000000000000000000000000000000000081565b34801561037357600080fd5b50610200610382366004611e6f565b610d15565b34801561039357600080fd5b506102006103a2366004611f51565b610d5a565b3480156103b357600080fd5b506103df6103c2366004611fd4565b600260209081526000928352604080842090915290825290205481565b604051908152602001610294565b3480156103f957600080fd5b507f0000000000000000000000000000000000000000000000000000000000000000610280565b34801561042c57600080fd5b506003546001600160a01b0316610280565b61020061044c36600461200d565b610e14565b34801561045d57600080fd5b5061020061046c366004611cf8565b610e56565b61020061047f366004611da9565b610e65565b34801561049057600080fd5b5061020061049f366004612070565b610f1c565b6102006104b236600461200d565b610f72565b6104c48484348585610fb5565b50505050565b6003546001600160a01b031633148015610579575060035460408051636e296e4560e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116931691636e296e459160048083019260209291908290030181865afa15801561054a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056e919061208d565b6001600160a01b0316145b6105f55760405162461bcd60e51b815260206004820152604160248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20746865206f746865722062726964676064820152606560f81b608482015260a4016101d9565b6105fe87611129565b156107125761060d8787611172565b6106925760405162461bcd60e51b815260206004820152604a60248201527f5374616e646172644272696467653a2077726f6e672072656d6f746520746f6b60448201527f656e20666f72204f7074696d69736d204d696e7461626c65204552433230206c60648201526937b1b0b6103a37b5b2b760b11b608482015260a4016101d9565b6040517f40c10f190000000000000000000000000000000000000000000000000000000081526001600160a01b038581166004830152602482018590528816906340c10f1990604401600060405180830381600087803b1580156106f557600080fd5b505af1158015610709573d6000803e3d6000fd5b5050505061077a565b6001600160a01b038088166000908152600260209081526040808320938a16835292905220546107439084906120d9565b6001600160a01b038089166000818152600260209081526040808320948c168352939052919091209190915561077a908585611245565b6107be878787878787878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506112c192505050565b50505050505050565b333b1561083c5760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b61087f3333348686868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610fb592505050565b505050565b6108918585858585610898565b5050505050565b6003546001600160a01b031633148015610947575060035460408051636e296e4560e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116931691636e296e459160048083019260209291908290030181865afa158015610918573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061093c919061208d565b6001600160a01b0316145b6109c35760405162461bcd60e51b815260206004820152604160248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20746865206f746865722062726964676064820152606560f81b608482015260a4016101d9565b823414610a385760405162461bcd60e51b815260206004820152603a60248201527f5374616e646172644272696467653a20616d6f756e742073656e7420646f657360448201527f206e6f74206d6174636820616d6f756e7420726571756972656400000000000060648201526084016101d9565b306001600160a01b03851603610ab65760405162461bcd60e51b815260206004820152602360248201527f5374616e646172644272696467653a2063616e6e6f742073656e6420746f207360448201527f656c66000000000000000000000000000000000000000000000000000000000060648201526084016101d9565b6003546001600160a01b0390811690851603610b3a5760405162461bcd60e51b815260206004820152602860248201527f5374616e646172644272696467653a2063616e6e6f742073656e6420746f206d60448201527f657373656e67657200000000000000000000000000000000000000000000000060648201526084016101d9565b610b7c85858585858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061132892505050565b6000610b99855a8660405180602001604052806000815250611381565b905080610c0e5760405162461bcd60e51b815260206004820152602360248201527f5374616e646172644272696467653a20455448207472616e736665722066616960448201527f6c6564000000000000000000000000000000000000000000000000000000000060648201526084016101d9565b505050505050565b6107be87873388888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061139b92505050565b333b15610cd05760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b610c0e86863333888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061162a92505050565b6107be87873388888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061162a92505050565b333b15610dcf5760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b610c0e86863333888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061139b92505050565b6104c433858585858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506104b792505050565b6107be878787878787876104ca565b333b15610eda5760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b61087f33338585858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506104b792505050565b6101026000556002610f2d82611639565b6000805461ff001916905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6104c43385348686868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610fb592505050565b82341461102a5760405162461bcd60e51b815260206004820152603e60248201527f5374616e646172644272696467653a206272696467696e6720455448206d757360448201527f7420696e636c7564652073756666696369656e74204554482076616c7565000060648201526084016101d9565b611036858585846116f0565b6003546040516001600160a01b0390911690633dbb202b9085907f0000000000000000000000000000000000000000000000000000000000000000907f1635f5fd00000000000000000000000000000000000000000000000000000000906110a8908b908b9086908a906024016120f0565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199485161790525160e086901b90921682526110f09291889060040161212c565b6000604051808303818588803b15801561110957600080fd5b505af115801561111d573d6000803e3d6000fd5b50505050505050505050565b600061113c82631d1d8b6360e01b611749565b8061116c575061116c827fec4fc8e300000000000000000000000000000000000000000000000000000000611749565b92915050565b600061118583631d1d8b6360e01b611749565b1561120757826001600160a01b031663c01e1bd66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ec919061208d565b6001600160a01b0316826001600160a01b031614905061116c565b826001600160a01b031663d6c0b2c46040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111c8573d6000803e3d6000fd5b6040516001600160a01b03831660248201526044810182905261087f9084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b03199093169290921790915261176c565b836001600160a01b0316856001600160a01b0316876001600160a01b03167f3ceee06c1e37648fcbb6ed52e17b3e1f275a1f8c7b22a84b2b84732431e046b386868660405161131293929190612164565b60405180910390a4610c0e868686868686611851565b826001600160a01b0316846001600160a01b03167f2ac69ee804d9a7a0984249f508dfab7cb2534b465b6ce1580f99a38ba9c5e631848460405161136d929190612195565b60405180910390a36104c4848484846118b2565b600080600080845160208601878a8af19695505050505050565b6113a487611129565b156114b8576113b38787611172565b6114385760405162461bcd60e51b815260206004820152604a60248201527f5374616e646172644272696467653a2077726f6e672072656d6f746520746f6b60448201527f656e20666f72204f7074696d69736d204d696e7461626c65204552433230206c60648201526937b1b0b6103a37b5b2b760b11b608482015260a4016101d9565b6040517f9dc29fac0000000000000000000000000000000000000000000000000000000081526001600160a01b03868116600483015260248201859052881690639dc29fac90604401600060405180830381600087803b15801561149b57600080fd5b505af11580156114af573d6000803e3d6000fd5b50505050611525565b6114cd6001600160a01b038816863086611905565b6001600160a01b038088166000908152600260209081526040808320938a16835292905220546114fe9084906121ae565b6001600160a01b038089166000908152600260209081526040808320938b16835292905220555b611533878787878786611956565b6003546040516001600160a01b0390911690633dbb202b907f0000000000000000000000000000000000000000000000000000000000000000907f0166a07a00000000000000000000000000000000000000000000000000000000906115a7908b908d908c908c908c908b906024016121c6565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199485161790525160e085901b90921682526115ef9291879060040161212c565b600060405180830381600087803b15801561160957600080fd5b505af115801561161d573d6000803e3d6000fd5b5050505050505050505050565b6107be8787878787878761139b565b600054610100900460ff166116b65760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016101d9565b600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091179055565b826001600160a01b0316846001600160a01b03167f35d79ab81f2b2017e19afb5c5571778877782d7a8786f5907f93b0f4702f4f238484604051611735929190612195565b60405180910390a36104c4848484846119bd565b600061175483611a02565b801561176557506117658383611a35565b9392505050565b60006117c1826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611abe9092919063ffffffff16565b80519091501561087f57808060200190518101906117df9190612214565b61087f5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016101d9565b836001600160a01b0316856001600160a01b0316876001600160a01b03167fd59c65b35445225835c83f50b6ede06a7be047d22e357073e250d9af537518cd8686866040516118a293929190612164565b60405180910390a4505050505050565b826001600160a01b0316846001600160a01b03167f31b2166ff604fc5672ea5df08a78081d2bc6d746cadce880747f3643d819e83d84846040516118f7929190612195565b60405180910390a350505050565b6040516001600160a01b03808516602483015283166044820152606481018290526104c49085907f23b872dd000000000000000000000000000000000000000000000000000000009060840161128a565b836001600160a01b0316856001600160a01b0316876001600160a01b03167f718594027abd4eaed59f95162563e0cc6d0e8d5b86b1c7be8b1b0ac3343d03968686866040516119a793929190612164565b60405180910390a4610c0e868686868686611ad5565b826001600160a01b0316846001600160a01b03167f2849b43074093a05396b6f2a937dee8565b15a48a7b3d4bffb732a5017380af584846040516118f7929190612195565b6000611a15826301ffc9a760e01b611a35565b801561116c5750611a2e826001600160e01b0319611a35565b1592915050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b178152825160009392849283928392918391908a617530fa92503d91506000519050828015611aa7575060208210155b8015611ab35750600081115b979650505050505050565b6060611acd8484600085611b26565b949350505050565b836001600160a01b0316856001600160a01b0316876001600160a01b03167f7ff126db8024424bbfd9826e8ab82ff59136289ea440b04b39a0df1b03b9cabf8686866040516118a293929190612164565b606082471015611b9e5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016101d9565b6001600160a01b0385163b611bf55760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016101d9565b600080866001600160a01b03168587604051611c119190612236565b60006040518083038185875af1925050503d8060008114611c4e576040519150601f19603f3d011682016040523d82523d6000602084013e611c53565b606091505b5091509150611ab382828660608315611c6d575081611765565b825115611c7d5782518084602001fd5b8160405162461bcd60e51b81526004016101d99190611f3e565b6001600160a01b0381168114611cac57600080fd5b50565b60008083601f840112611cc157600080fd5b50813567ffffffffffffffff811115611cd957600080fd5b602083019150836020828501011115611cf157600080fd5b9250929050565b600080600080600080600060c0888a031215611d1357600080fd5b8735611d1e81611c97565b96506020880135611d2e81611c97565b95506040880135611d3e81611c97565b94506060880135611d4e81611c97565b93506080880135925060a088013567ffffffffffffffff811115611d7157600080fd5b611d7d8a828b01611caf565b989b979a50959850939692959293505050565b803563ffffffff81168114611da457600080fd5b919050565b600080600060408486031215611dbe57600080fd5b611dc784611d90565b9250602084013567ffffffffffffffff811115611de357600080fd5b611def86828701611caf565b9497909650939450505050565b600080600080600060808688031215611e1457600080fd5b8535611e1f81611c97565b94506020860135611e2f81611c97565b935060408601359250606086013567ffffffffffffffff811115611e5257600080fd5b611e5e88828901611caf565b969995985093965092949392505050565b600080600080600080600060c0888a031215611e8a57600080fd5b8735611e9581611c97565b96506020880135611ea581611c97565b95506040880135611eb581611c97565b945060608801359350611eca60808901611d90565b925060a088013567ffffffffffffffff811115611d7157600080fd5b60005b83811015611f01578181015183820152602001611ee9565b838111156104c45750506000910152565b60008151808452611f2a816020860160208601611ee6565b601f01601f19169290920160200192915050565b6020815260006117656020830184611f12565b60008060008060008060a08789031215611f6a57600080fd5b8635611f7581611c97565b95506020870135611f8581611c97565b945060408701359350611f9a60608801611d90565b9250608087013567ffffffffffffffff811115611fb657600080fd5b611fc289828a01611caf565b979a9699509497509295939492505050565b60008060408385031215611fe757600080fd5b8235611ff281611c97565b9150602083013561200281611c97565b809150509250929050565b6000806000806060858703121561202357600080fd5b843561202e81611c97565b935061203c60208601611d90565b9250604085013567ffffffffffffffff81111561205857600080fd5b61206487828801611caf565b95989497509550505050565b60006020828403121561208257600080fd5b813561176581611c97565b60006020828403121561209f57600080fd5b815161176581611c97565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000828210156120eb576120eb6120aa565b500390565b60006001600160a01b038087168352808616602084015250836040830152608060608301526121226080830184611f12565b9695505050505050565b6001600160a01b038416815260606020820152600061214e6060830185611f12565b905063ffffffff83166040830152949350505050565b6001600160a01b038416815282602082015260606040820152600061218c6060830184611f12565b95945050505050565b828152604060208201526000611acd6040830184611f12565b600082198211156121c1576121c16120aa565b500190565b60006001600160a01b0380891683528088166020840152808716604084015280861660608401525083608083015260c060a083015261220860c0830184611f12565b98975050505050505050565b60006020828403121561222657600080fd5b8151801515811461176557600080fd5b60008251612248818460208701611ee6565b919091019291505056fea26469706673582212200d8ab5f054037292ca78c5c5cd164e32ae470679e67b033c9afd86de61d4bd3564736f6c634300080f0033a264697066735822122038d6ebd84d8fc9bde3053e593d1aec5c74e0f1442f05b9351d869ba3ef1149f264736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806331d191661461003b57806354fd4d5014610059575b600080fd5b610043610061565b60405161005091906102d4565b60405180910390f35b61004361008b565b6060604051806020016100739061026b565b601f1982820381018352601f90910116604052919050565b60606100b67f000000000000000000000000000000000000000000000000000000000000000061012e565b6100df7f000000000000000000000000000000000000000000000000000000000000000061012e565b6101087f000000000000000000000000000000000000000000000000000000000000000061012e565b60405160200161011a939291906102ee565b604051602081830303815290604052905090565b60608160000361017157505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b8160005b811561019b57806101858161037a565b91506101949050600a836103a9565b9150610175565b60008167ffffffffffffffff8111156101b6576101b66103bd565b6040519080825280601f01601f1916602001820160405280156101e0576020820181803683370190505b5090505b8415610263576101f56001836103d3565b9150610202600a866103ea565b61020d9060306103fe565b60f81b81838151811061022257610222610416565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535061025c600a866103a9565b94506101e4565b949350505050565b61240b8061042d83390190565b60005b8381101561029357818101518382015260200161027b565b838111156102a2576000848401525b50505050565b600081518084526102c0816020860160208601610278565b601f01601f19169290920160200192915050565b6020815260006102e760208301846102a8565b9392505050565b60008451610300818460208901610278565b80830190507f2e00000000000000000000000000000000000000000000000000000000000000808252855161033c816001850160208a01610278565b60019201918201528351610357816002840160208801610278565b0160020195945050505050565b634e487b7160e01b600052601160045260246000fd5b60006001820161038c5761038c610364565b5060010190565b634e487b7160e01b600052601260045260246000fd5b6000826103b8576103b8610393565b500490565b634e487b7160e01b600052604160045260246000fd5b6000828210156103e5576103e5610364565b500390565b6000826103f9576103f9610393565b500690565b6000821982111561041157610411610364565b500190565b634e487b7160e01b600052603260045260246000fdfe60a06040523480156200001157600080fd5b507342000000000000000000000000000000000000106080526200003660006200003c565b62000144565b60008055600262000051565b60405180910390fd5b6000805461ffff191660ff8316176101001790556200007082620000b5565b6000805461ff001916905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b600054610100900460ff16620001225760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b606482015260840162000048565b600380546001600160a01b0319166001600160a01b0392909216919091179055565b6080516122886200018360003960008181610345015281816103fc015281816104fc015281816108ca01528181611052015261154d01526122886000f3fe6080604052600436106101635760003560e01c806387087623116100c0578063a9f9e67511610074578063c4d66de811610059578063c4d66de814610484578063c89701a2146103ed578063e11013dd146104a457600080fd5b8063a9f9e67514610451578063b1a1a8821461047157600080fd5b806391c49bf8116100a557806391c49bf8146103ed578063927ede2d146104205780639a2ac6d51461043e57600080fd5b806387087623146103875780638f601f66146103a757600080fd5b8063540abf731161011757806358a997f6116100fc57806358a997f6146103135780637f46ddb214610333578063838b25201461036757600080fd5b8063540abf731461029d57806354fd4d50146102bd57600080fd5b80631532ec34116101485780631532ec341461023a5780631635f5fd1461024d5780633cb747bf1461026057600080fd5b80630166a07a1461020757806309fc88431461022757600080fd5b3661020257333b156101e25760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084015b60405180910390fd5b610200333362030d40604051806020016040528060008152506104b7565b005b600080fd5b34801561021357600080fd5b50610200610222366004611cf8565b6104ca565b610200610235366004611da9565b6107c7565b610200610248366004611dfc565b610884565b61020061025b366004611dfc565b610898565b34801561026c57600080fd5b50600354610280906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156102a957600080fd5b506102006102b8366004611e6f565b610c16565b3480156102c957600080fd5b506103066040518060400160405280600581526020017f312e332e3000000000000000000000000000000000000000000000000000000081525081565b6040516102949190611f3e565b34801561031f57600080fd5b5061020061032e366004611f51565b610c5b565b34801561033f57600080fd5b506102807f000000000000000000000000000000000000000000000000000000000000000081565b34801561037357600080fd5b50610200610382366004611e6f565b610d15565b34801561039357600080fd5b506102006103a2366004611f51565b610d5a565b3480156103b357600080fd5b506103df6103c2366004611fd4565b600260209081526000928352604080842090915290825290205481565b604051908152602001610294565b3480156103f957600080fd5b507f0000000000000000000000000000000000000000000000000000000000000000610280565b34801561042c57600080fd5b506003546001600160a01b0316610280565b61020061044c36600461200d565b610e14565b34801561045d57600080fd5b5061020061046c366004611cf8565b610e56565b61020061047f366004611da9565b610e65565b34801561049057600080fd5b5061020061049f366004612070565b610f1c565b6102006104b236600461200d565b610f72565b6104c48484348585610fb5565b50505050565b6003546001600160a01b031633148015610579575060035460408051636e296e4560e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116931691636e296e459160048083019260209291908290030181865afa15801561054a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056e919061208d565b6001600160a01b0316145b6105f55760405162461bcd60e51b815260206004820152604160248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20746865206f746865722062726964676064820152606560f81b608482015260a4016101d9565b6105fe87611129565b156107125761060d8787611172565b6106925760405162461bcd60e51b815260206004820152604a60248201527f5374616e646172644272696467653a2077726f6e672072656d6f746520746f6b60448201527f656e20666f72204f7074696d69736d204d696e7461626c65204552433230206c60648201526937b1b0b6103a37b5b2b760b11b608482015260a4016101d9565b6040517f40c10f190000000000000000000000000000000000000000000000000000000081526001600160a01b038581166004830152602482018590528816906340c10f1990604401600060405180830381600087803b1580156106f557600080fd5b505af1158015610709573d6000803e3d6000fd5b5050505061077a565b6001600160a01b038088166000908152600260209081526040808320938a16835292905220546107439084906120d9565b6001600160a01b038089166000818152600260209081526040808320948c168352939052919091209190915561077a908585611245565b6107be878787878787878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506112c192505050565b50505050505050565b333b1561083c5760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b61087f3333348686868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610fb592505050565b505050565b6108918585858585610898565b5050505050565b6003546001600160a01b031633148015610947575060035460408051636e296e4560e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116931691636e296e459160048083019260209291908290030181865afa158015610918573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061093c919061208d565b6001600160a01b0316145b6109c35760405162461bcd60e51b815260206004820152604160248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20746865206f746865722062726964676064820152606560f81b608482015260a4016101d9565b823414610a385760405162461bcd60e51b815260206004820152603a60248201527f5374616e646172644272696467653a20616d6f756e742073656e7420646f657360448201527f206e6f74206d6174636820616d6f756e7420726571756972656400000000000060648201526084016101d9565b306001600160a01b03851603610ab65760405162461bcd60e51b815260206004820152602360248201527f5374616e646172644272696467653a2063616e6e6f742073656e6420746f207360448201527f656c66000000000000000000000000000000000000000000000000000000000060648201526084016101d9565b6003546001600160a01b0390811690851603610b3a5760405162461bcd60e51b815260206004820152602860248201527f5374616e646172644272696467653a2063616e6e6f742073656e6420746f206d60448201527f657373656e67657200000000000000000000000000000000000000000000000060648201526084016101d9565b610b7c85858585858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061132892505050565b6000610b99855a8660405180602001604052806000815250611381565b905080610c0e5760405162461bcd60e51b815260206004820152602360248201527f5374616e646172644272696467653a20455448207472616e736665722066616960448201527f6c6564000000000000000000000000000000000000000000000000000000000060648201526084016101d9565b505050505050565b6107be87873388888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061139b92505050565b333b15610cd05760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b610c0e86863333888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061162a92505050565b6107be87873388888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061162a92505050565b333b15610dcf5760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b610c0e86863333888888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061139b92505050565b6104c433858585858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506104b792505050565b6107be878787878787876104ca565b333b15610eda5760405162461bcd60e51b815260206004820152603760248201527f5374616e646172644272696467653a2066756e6374696f6e2063616e206f6e6c60448201527f792062652063616c6c65642066726f6d20616e20454f4100000000000000000060648201526084016101d9565b61087f33338585858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506104b792505050565b6101026000556002610f2d82611639565b6000805461ff001916905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6104c43385348686868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610fb592505050565b82341461102a5760405162461bcd60e51b815260206004820152603e60248201527f5374616e646172644272696467653a206272696467696e6720455448206d757360448201527f7420696e636c7564652073756666696369656e74204554482076616c7565000060648201526084016101d9565b611036858585846116f0565b6003546040516001600160a01b0390911690633dbb202b9085907f0000000000000000000000000000000000000000000000000000000000000000907f1635f5fd00000000000000000000000000000000000000000000000000000000906110a8908b908b9086908a906024016120f0565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199485161790525160e086901b90921682526110f09291889060040161212c565b6000604051808303818588803b15801561110957600080fd5b505af115801561111d573d6000803e3d6000fd5b50505050505050505050565b600061113c82631d1d8b6360e01b611749565b8061116c575061116c827fec4fc8e300000000000000000000000000000000000000000000000000000000611749565b92915050565b600061118583631d1d8b6360e01b611749565b1561120757826001600160a01b031663c01e1bd66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ec919061208d565b6001600160a01b0316826001600160a01b031614905061116c565b826001600160a01b031663d6c0b2c46040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111c8573d6000803e3d6000fd5b6040516001600160a01b03831660248201526044810182905261087f9084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b03199093169290921790915261176c565b836001600160a01b0316856001600160a01b0316876001600160a01b03167f3ceee06c1e37648fcbb6ed52e17b3e1f275a1f8c7b22a84b2b84732431e046b386868660405161131293929190612164565b60405180910390a4610c0e868686868686611851565b826001600160a01b0316846001600160a01b03167f2ac69ee804d9a7a0984249f508dfab7cb2534b465b6ce1580f99a38ba9c5e631848460405161136d929190612195565b60405180910390a36104c4848484846118b2565b600080600080845160208601878a8af19695505050505050565b6113a487611129565b156114b8576113b38787611172565b6114385760405162461bcd60e51b815260206004820152604a60248201527f5374616e646172644272696467653a2077726f6e672072656d6f746520746f6b60448201527f656e20666f72204f7074696d69736d204d696e7461626c65204552433230206c60648201526937b1b0b6103a37b5b2b760b11b608482015260a4016101d9565b6040517f9dc29fac0000000000000000000000000000000000000000000000000000000081526001600160a01b03868116600483015260248201859052881690639dc29fac90604401600060405180830381600087803b15801561149b57600080fd5b505af11580156114af573d6000803e3d6000fd5b50505050611525565b6114cd6001600160a01b038816863086611905565b6001600160a01b038088166000908152600260209081526040808320938a16835292905220546114fe9084906121ae565b6001600160a01b038089166000908152600260209081526040808320938b16835292905220555b611533878787878786611956565b6003546040516001600160a01b0390911690633dbb202b907f0000000000000000000000000000000000000000000000000000000000000000907f0166a07a00000000000000000000000000000000000000000000000000000000906115a7908b908d908c908c908c908b906024016121c6565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199485161790525160e085901b90921682526115ef9291879060040161212c565b600060405180830381600087803b15801561160957600080fd5b505af115801561161d573d6000803e3d6000fd5b5050505050505050505050565b6107be8787878787878761139b565b600054610100900460ff166116b65760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016101d9565b600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091179055565b826001600160a01b0316846001600160a01b03167f35d79ab81f2b2017e19afb5c5571778877782d7a8786f5907f93b0f4702f4f238484604051611735929190612195565b60405180910390a36104c4848484846119bd565b600061175483611a02565b801561176557506117658383611a35565b9392505050565b60006117c1826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611abe9092919063ffffffff16565b80519091501561087f57808060200190518101906117df9190612214565b61087f5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016101d9565b836001600160a01b0316856001600160a01b0316876001600160a01b03167fd59c65b35445225835c83f50b6ede06a7be047d22e357073e250d9af537518cd8686866040516118a293929190612164565b60405180910390a4505050505050565b826001600160a01b0316846001600160a01b03167f31b2166ff604fc5672ea5df08a78081d2bc6d746cadce880747f3643d819e83d84846040516118f7929190612195565b60405180910390a350505050565b6040516001600160a01b03808516602483015283166044820152606481018290526104c49085907f23b872dd000000000000000000000000000000000000000000000000000000009060840161128a565b836001600160a01b0316856001600160a01b0316876001600160a01b03167f718594027abd4eaed59f95162563e0cc6d0e8d5b86b1c7be8b1b0ac3343d03968686866040516119a793929190612164565b60405180910390a4610c0e868686868686611ad5565b826001600160a01b0316846001600160a01b03167f2849b43074093a05396b6f2a937dee8565b15a48a7b3d4bffb732a5017380af584846040516118f7929190612195565b6000611a15826301ffc9a760e01b611a35565b801561116c5750611a2e826001600160e01b0319611a35565b1592915050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180516001600160e01b03166301ffc9a760e01b178152825160009392849283928392918391908a617530fa92503d91506000519050828015611aa7575060208210155b8015611ab35750600081115b979650505050505050565b6060611acd8484600085611b26565b949350505050565b836001600160a01b0316856001600160a01b0316876001600160a01b03167f7ff126db8024424bbfd9826e8ab82ff59136289ea440b04b39a0df1b03b9cabf8686866040516118a293929190612164565b606082471015611b9e5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016101d9565b6001600160a01b0385163b611bf55760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016101d9565b600080866001600160a01b03168587604051611c119190612236565b60006040518083038185875af1925050503d8060008114611c4e576040519150601f19603f3d011682016040523d82523d6000602084013e611c53565b606091505b5091509150611ab382828660608315611c6d575081611765565b825115611c7d5782518084602001fd5b8160405162461bcd60e51b81526004016101d99190611f3e565b6001600160a01b0381168114611cac57600080fd5b50565b60008083601f840112611cc157600080fd5b50813567ffffffffffffffff811115611cd957600080fd5b602083019150836020828501011115611cf157600080fd5b9250929050565b600080600080600080600060c0888a031215611d1357600080fd5b8735611d1e81611c97565b96506020880135611d2e81611c97565b95506040880135611d3e81611c97565b94506060880135611d4e81611c97565b93506080880135925060a088013567ffffffffffffffff811115611d7157600080fd5b611d7d8a828b01611caf565b989b979a50959850939692959293505050565b803563ffffffff81168114611da457600080fd5b919050565b600080600060408486031215611dbe57600080fd5b611dc784611d90565b9250602084013567ffffffffffffffff811115611de357600080fd5b611def86828701611caf565b9497909650939450505050565b600080600080600060808688031215611e1457600080fd5b8535611e1f81611c97565b94506020860135611e2f81611c97565b935060408601359250606086013567ffffffffffffffff811115611e5257600080fd5b611e5e88828901611caf565b969995985093965092949392505050565b600080600080600080600060c0888a031215611e8a57600080fd5b8735611e9581611c97565b96506020880135611ea581611c97565b95506040880135611eb581611c97565b945060608801359350611eca60808901611d90565b925060a088013567ffffffffffffffff811115611d7157600080fd5b60005b83811015611f01578181015183820152602001611ee9565b838111156104c45750506000910152565b60008151808452611f2a816020860160208601611ee6565b601f01601f19169290920160200192915050565b6020815260006117656020830184611f12565b60008060008060008060a08789031215611f6a57600080fd5b8635611f7581611c97565b95506020870135611f8581611c97565b945060408701359350611f9a60608801611d90565b9250608087013567ffffffffffffffff811115611fb657600080fd5b611fc289828a01611caf565b979a9699509497509295939492505050565b60008060408385031215611fe757600080fd5b8235611ff281611c97565b9150602083013561200281611c97565b809150509250929050565b6000806000806060858703121561202357600080fd5b843561202e81611c97565b935061203c60208601611d90565b9250604085013567ffffffffffffffff81111561205857600080fd5b61206487828801611caf565b95989497509550505050565b60006020828403121561208257600080fd5b813561176581611c97565b60006020828403121561209f57600080fd5b815161176581611c97565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000828210156120eb576120eb6120aa565b500390565b60006001600160a01b038087168352808616602084015250836040830152608060608301526121226080830184611f12565b9695505050505050565b6001600160a01b038416815260606020820152600061214e6060830185611f12565b905063ffffffff83166040830152949350505050565b6001600160a01b038416815282602082015260606040820152600061218c6060830184611f12565b95945050505050565b828152604060208201526000611acd6040830184611f12565b600082198211156121c1576121c16120aa565b500190565b60006001600160a01b0380891683528088166020840152808716604084015280861660608401525083608083015260c060a083015261220860c0830184611f12565b98975050505050505050565b60006020828403121561222657600080fd5b8151801515811461176557600080fd5b60008251612248818460208701611ee6565b919091019291505056fea26469706673582212200d8ab5f054037292ca78c5c5cd164e32ae470679e67b033c9afd86de61d4bd3564736f6c634300080f0033a264697066735822122038d6ebd84d8fc9bde3053e593d1aec5c74e0f1442f05b9351d869ba3ef1149f264736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "version()": {
        "returns": {
          "_0": "Semver contract version as a string."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deployBytecode()": {
        "notice": "The create2 salt used for deployment of the contract implementations."
      },
      "version()": {
        "notice": "Returns the full semver contract version."
      }
    },
    "notice": "Hold the deployment bytecode         Separate from build contract to avoid bytecode size limitations",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}